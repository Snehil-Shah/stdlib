/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-invalid-this, no-underscore-dangle */

'use strict';

// MODULES //

var readline = require( 'readline' );
var logger = require( 'debug' );
var format = require( '@stdlib/string/format' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var objectKeys = require( '@stdlib/utils/keys' );
var omit = require( '@stdlib/utils/omit' );
var contains = require('@stdlib/array/base/assert/contains');
var tokenizer = require( './tokenizer.js' );
var THEMES = require( './themes.js' );
var ANSI = require( './ansi_colors.js' );


// VARIABLES //

var debug = logger( 'repl:syntax-highlighter' );


// FUNCTIONS //

/**
* Compare function for sorting tokens in ascending order of their indices.
*
* @private
* @param {Object} a - first token
* @param {Object} b - second token
* @returns {boolean} boolean indicating if the first token is greater
*/
function tokenComparator( a, b ) {
	return a.start - b.start;
}


// MAIN //

/**
* Constructor for creating a syntax-highlighter.
*
* @private
* @constructor
* @param {REPL} repl - REPL instance
* @param {WritableStream} ostream - writable stream
* @returns {SyntaxHighlighter} syntax-highlighter instance
*/
function SyntaxHighlighter( repl, ostream ) {
	if ( !( this instanceof SyntaxHighlighter ) ) {
		return new SyntaxHighlighter( repl, ostream );
	}
	debug( 'Creating a new syntax-highlighter' );

	// Cache a reference to the provided REPL instance:
	this._repl = repl;

	// Cache a reference to the provided readline interface:
	this._rli = repl._rli;

	// Cache a reference to the output writable stream:
	this._ostream = ostream;

	// Initialize a buffer containing the current line to validate line changes:
	this._line = '';

	// Initialize a buffer to cache the highlighted line:
	this._highlightedLine = '';

	// Initialize an object storing all available themes:
	this._themes = THEMES;

	// Initialize a variable storing the current theme:
	this._theme = 'default';

	// Initialize a variable storing the default theme:
	this._defaultTheme = 'default';

	return this;
}

/**
* Highlights the input line.
*
* @private
* @name _highlightLine
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @param {str} line - input line
* @param {Array} tokens - array of tokens in the line
* @returns {str} highlighted line
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, '_highlightLine', function highlightLine( line, tokens ) {
	var highlightedLine = '';
	var resetCode = ANSI[ 'reset' ];
	var colorCode;
	var colors = this._themes[ this._theme ];
	var offset = 0;
	var token;
	var i;

	// Sort and traverse the tokens...
	tokens.sort( tokenComparator );
	for ( i = 0; i < tokens.length; i++ ) {
		token = tokens[ i ];
		colorCode = ANSI[ colors[ token.type ] ];

		// Highlight token if it's color exists in the theme...
		if ( colorCode ) {
			highlightedLine += line.slice( offset, token.start ); // add text before token
			highlightedLine += colorCode; // insert colorCode
			highlightedLine += line.slice( token.start, token.end ); // add token
			highlightedLine += resetCode; // reset color
			offset = token.end;
		}
	}
	highlightedLine += line.slice( offset ); // add remaining text

	return highlightedLine;
});

/**
* Gets all available theme names.
*
* @name getThemes
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @returns {Array} array of all theme names
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'getThemes', function getThemes() {
	return objectKeys( this._themes );
});

/**
* Sets the current color theme.
*
* @name setTheme
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @param {string} theme - theme name
* @throws {Error} argument must be an existing theme
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'setTheme', function setTheme( theme ) {
	if ( !contains( objectKeys( this._themes ), theme ) ) {
		throw new Error( format( 'invalid argument. First argument must be an existing theme name. Value: `%s`.', theme ) );
	}
	this._highlightedLine = '';
	this._theme = theme;
});

/**
* Gets current theme name.
*
* @name getTheme
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @returns {Object} theme name
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'getTheme', function getTheme() {
	return this._theme;
});

/**
* Gets a theme's colors configuration.
*
* @name getThemeConfig
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @param {string} theme - theme name
* @throws {Error} must provide an existing theme name
* @returns {Object} theme object
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'getThemeConfig', function getThemeConfig( theme ) {
	if ( !contains( objectKeys( this._themes ), theme ) ) {
		throw new Error( format( 'invalid argument. First argument must be an existing theme name. Value: `%s`.', theme ) );
	}
	return this._themes[ theme ];
});

/**
* Gets the default color theme name.
*
* @name getDefaultTheme
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @returns {string} default theme name
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'getDefaultTheme', function getDefaultTheme() {
	return this._defaultTheme;
});

/**
* Sets the default color theme.
*
* @name setDefaultTheme
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @param {string} theme - theme name
* @throws {Error} argument must be an existing theme
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'setDefaultTheme', function setDefaultTheme( theme ) {
	if ( !contains( objectKeys( this._themes ), theme ) ) {
		throw new Error( format( 'invalid argument. First argument must be an existing theme name. Value: `%s`.', theme ) );
	}
	this._defaultTheme = theme;
});

/**
* Adds a new color theme.
*
* @name addTheme
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @param {Object} theme - theme object
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'addTheme', function addTheme( name, theme ) {
	this._themes[ name ] = theme;
});

/**
* Deletes a color theme.
*
* @name deleteTheme
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @param {Object} theme - theme name
* @throws {Error} must provide an existing theme name
* @throws {Error} must provide a theme other than the default theme
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'deleteTheme', function deleteTheme( theme ) {
	if ( !contains( objectKeys( this._themes ), theme ) ) {
		throw new Error( format( 'invalid argument. First argument must be an existing theme name. Value: `%s`.', theme ) );
	}
	if ( theme === this._defaultTheme ) {
		throw new Error( format( 'invalid argument. First argument cannot be the default theme. Value: `%s`.', theme ) );
	}
	if ( theme === this._theme ) {
		this._highlightedLine = '';
		this._theme = this._defaultTheme;
	}
	this._themes = omit( this._themes, theme );
});

/**
* Callback for handling a "keypress" event.
*
* @name onKeypress
* @memberof SyntaxHighlighter.prototype
* @type {Function}
* @param {string} data - input data
* @param {(Object|void)} key - key object
* @returns {void}
*/
setNonEnumerableReadOnly( SyntaxHighlighter.prototype, 'onKeypress', function onKeypress() {
	var highlightedLine;
	var tokens;

	if ( !this._rli.line ) {
		debug( 'Empty line detected. Skipping highlighting...' );
		return;
	}

	// If no line change is detected, use the highlighted line from cache...
	if ( this._line === this._rli.line ) {
		debug( 'No line change detected. Using cache...' );
		highlightedLine = this._highlightedLine;
	} else {
		// Update line buffer:
		this._line = this._rli.line;

		// Tokenize:
		debug( 'Line change detected. Tokenizing line: %s', this._line );
		tokens = tokenizer( this._line, this._repl._context );
		if ( !tokens ) {
			debug( 'No tokens found. Skipping highlighting...' );
			return;
		}
		// Highlight:
		debug( '%d tokens found. Highlighting...', tokens.length );
		highlightedLine = this._highlightLine( this._line, tokens );

		// Cache the newly highlighted line:
		this._highlightedLine = highlightedLine;
	}
	// Replace:
	debug( 'Replacing current line with the highlighted line...' );
	readline.moveCursor( this._ostream, -1 * this._rli.cursor, 0 );
	readline.clearLine( this._ostream, 1 );
	this._ostream.write( highlightedLine );
	readline.moveCursor( this._ostream, this._rli.cursor - this._line.length, 0 ); // eslint-disable-line max-len
});


// EXPORTS //

module.exports = SyntaxHighlighter;
