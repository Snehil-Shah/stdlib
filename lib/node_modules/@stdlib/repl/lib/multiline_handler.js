/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-underscore-dangle, no-restricted-syntax, no-invalid-this */

'use strict';

// MODULES //

var readline = require( 'readline' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var min = require( '@stdlib/math/base/special/min' );


// MAIN //

/**
* Constructor for creating a multiline handler.
*
* @private
* @constructor
* @param {REPL} repl - REPL instance
* @param {Function} ttyWrite - function to trigger default behavior of a keypress
* @returns {MultilineHandler} multiline handler instance
*/
function MultilineHandler( repl, ttyWrite ) {
	if ( !( this instanceof MultilineHandler ) ) {
		return new MultilineHandler( repl );
	}

	// Cache a reference to the provided REPL instance:
	this._repl = repl;

	// Cache a reference to the readline interface:
	this._rli = repl._rli;

	// Cache a reference to the output writable stream:
	this._ostream = repl._ostream;

	// Cache a reference to the private readline interface `ttyWrite` to allow calling the method when wanting default behavior:
	this._ttyWrite = ttyWrite;

	// Cache a reference to the multiline status object:
	this._multiline = repl._multiline;

	return this;
}

/**
* Returns cursor offset for the current line index based on the prompt.
*
* @private
* @name _xOffset
* @memberof MultilineHandler.prototype
* @type {Function}
* @returns {number} `x` offset
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, '_xOffset', function xOffset() {
	// If on first line, include length of input prompt as offset...
	if ( this._multiline.line === 0 ) {
		return this._repl._inputPrompt.length - 1;
	}
	return 0;
});

/**
* Renders remaining lines.
*
* @name renderLines
* @memberof MultilineHandler.prototype
* @type {Function}
* @returns {void}
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, 'renderLines', function renderLines() {
	var lines;

	// Clear existing renders:
	readline.clearScreenDown( this._ostream );

	// Write remaining lines below the current line:
	lines = this._multiline.lines.slice( this._multiline.line + 1 );
	this._ostream.write( '\n' + lines.join('\n') );

	// Reset cursor position:
	readline.moveCursor( this._ostream, 0, min( -1 * lines.length, -1 ) );
	readline.cursorTo( this._ostream, this._xOffset() + this._rli.cursor );
});

/**
* Moves cursor to a specified position in the multiline input.
*
* @private
* @name _moveCursor
* @memberof MultilineHandler.prototype
* @type {Function}
* @param {number} x - cursor position on the line
* @param {number} dy - number of lines to move down
* @returns {void}
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, '_moveCursor', function moveCursor( x, dy ) {
	// Clear any existing completion previews before moving lines:
	this._repl._previewCompleter.clear();

	// Change line:
	this._multiline.line += dy;
	readline.moveCursor( this._ostream, 0, dy );
	this._rli.line = this._repl._cmd[ this._multiline.line ];
	if ( this._multiline.line === 0 ) {
		// Refresh prompt if moved to first line:
		this._rli.setPrompt( this._repl._prompt() );
		this._rli.prompt();
	}
	// Set x cursor position:
	readline.cursorTo( this._ostream, this._xOffset() + x );
	this._rli.cursor = x;
});

/**
* Moves cursor up to the previous line.
*
* @private
* @name _moveUp
* @memberof MultilineHandler.prototype
* @type {Function}
* @returns {void}
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, '_moveUp', function moveUp() {
	var x;

	// If already at the first line, ignore...
	if ( this._multiline.line <= 0 ) {
		return;
	}
	this._repl._cmd[ this._multiline.line ] = this._rli.line; // update current line in command

	// Make sure the cursor never exceeds the length of the line:
	x = min( this._rli.cursor, this._repl._cmd[ this._multiline.line - 1 ].length ); // eslint-disable-line max-len
	this._moveCursor( x, -1 );
});

/**
* Moves cursor down to the next line.
*
* @private
* @name _moveDown
* @memberof MultilineHandler.prototype
* @type {Function}
* @returns {void}
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, '_moveDown', function moveDown() {
	var x;

	// If already at the last line, ignore...
	if ( this._multiline.line >= this._multiline.lines.length - 1 ) {
		return;
	}
	this._repl._cmd[ this._multiline.line ] = this._rli.line; // update current line in command

	// Make sure the cursor never exceeds the length of the line:
	x = min( this._rli.cursor, this._repl._cmd[ this._multiline.line + 1 ].length ); // eslint-disable-line max-len
	this._moveCursor( x, 1 );
});

/**
* Moves cursor left to the end of the previous line.
*
* @private
* @name _moveLeft
* @memberof MultilineHandler.prototype
* @type {Function}
* @returns {void}
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, '_moveLeft', function moveLeft() {
	// If already at the first line, ignore...
	if ( this._multiline.line <= 0 ) {
		return;
	}
	this._repl._cmd[ this._multiline.line ] = this._rli.line; // update current line in command

	// Move cursor to the end of the previous line:
	this._moveCursor( this._repl._cmd[ this._multiline.line - 1 ].length, -1 );
});

/**
* Moves cursor right to the start of the next line.
*
* @private
* @name _moveRight
* @memberof MultilineHandler.prototype
* @type {Function}
* @returns {void}
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, '_moveRight', function moveRight() {
	// If already at the last line, ignore...
	if ( this._multiline.line >= this._multiline.lines.length - 1 ) {
		return;
	}
	this._repl._cmd[ this._multiline.line ] = this._rli.line; // update current line in command

	// Move cursor to the start of the next line:
	this._moveCursor( 0, 1 );
});

/**
* Simulates a backspace by removing the current line and appending it to the previous line.
*
* @private
* @name _backspace
* @memberof MultilineHandler.prototype
* @type {Function}
* @returns {void}
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, '_backspace', function backspace() {
	var x;

	// If already at the first line, ignore...
	if ( this._multiline.line <= 0 ) {
		return;
	}
	// Save cursor position:
	x = this._repl._cmd[ this._multiline.line - 1 ].length;

	// Append current line to the previous line:
	this._repl._cmd[ this._multiline.line - 1 ] += this._rli.line;
	this._multiline.lines[ this._multiline.line - 1 ] += this._multiline.lines[ this._multiline.line ]; // eslint-disable-line max-len

	// Remove current line:
	this._repl._cmd.splice( this._multiline.line, 1 );
	this._multiline.lines.splice( this._multiline.line, 1 );

	// Move cursor to the saved cursor position in the previous line:
	this._moveCursor( x, -1 );

	// If we deleted all multilines, update flag...
	if ( this._multiline.lines.length <= 1 ) {
		this._multiline.active = false;
	}
});

/**
* Callback for handling a "keypress" event.
*
* @name onKeypress
* @memberof MultilineHandler.prototype
* @type {Function}
* @param {string} data - input data
* @param {(Object|void)} key - key object
* @returns {void}
*/
setNonEnumerableReadOnly( MultilineHandler.prototype, 'onKeypress', function onKeypress( data, key ) {
	if ( !key ) {
		return;
	}
	// Add manual newline when encountering `CTRL+E` keybinding...
	if ( key.name === 'e' && key.ctrl ) {
		// Update flags:
		this._multiline.active = true;
		this._multiline.mode = 'manual';

		// Save expression after cursor in buffer:
		readline.clearLine( this._ostream, 1 );
		this._multiline.buffer = this._rli.line.substring( this._rli.cursor );
		this._rli.line = this._rli.line.substring( 0, this._rli.cursor );

		// Simulate `line` event:
		this._rli.write( '\n' );
	} else if ( this._multiline.active ) {
		// Render remaining lines with each keypress when in multiline mode:
		this.renderLines();
	}
});

/**
* Callback which should be invoked **before** a "keypress" event is processed by a readline interface.
*
* @name beforeKeypress
* @memberof MultilineHandler.prototype
* @type {Function}
* @param {string} data - input data
* @param {(Object|void)} key - key object
* @returns {void}
*/
setNonEnumerableReadOnly(MultilineHandler.prototype, 'beforeKeypress', function beforeKeypress(data, key) {
	if (!key) {
		this._ttyWrite.call(this._rli, data, key);
		return;
	}
	switch ( key.name ) {
	case 'up':
		this._moveUp();
		this.renderLines();
		break;
	case 'down':
		this._moveDown();
		this.renderLines();
		break;
	case 'left':
		// If at the beginning of the line, move up to the previous line, else trigger default behavior...
		if ( this._rli.cursor === 0 ) {
			this._moveLeft();
			this.renderLines();
			return;
		}
		this._ttyWrite.call( this._rli, data, key );
		break;
	case 'right':
		// If at the end of the line, move up to the next line, else trigger default behavior...
		if ( this._rli.cursor === this._rli.line.length ) {
			this._moveRight();
			this.renderLines();
			return;
		}
		this._ttyWrite.call( this._rli, data, key );
		break;
	case 'backspace':
		// If at the beginning of the line, remove and move up to the previous line, else trigger default behavior...
		if ( this._rli.cursor === 0 ) {
			this._backspace();
			this.renderLines();
			return;
		}
		this._ttyWrite.call( this._rli, data, key );
		break;
	default:
		this._ttyWrite.call( this._rli, data, key );
		break;
	}
});


// EXPORTS //

module.exports = MultilineHandler;
