/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var parse = require( 'acorn-loose' ).parse;
var commands = require( './commands.js' );


// VARIABLES //

var COMMANDS = commands();


// MAIN //

/**
* Tokenizes the input line based on ECMAScript specification.
*
* @private
* @name tokenizer
* @type {Function}
* @param {string} line - input line
* @returns {Array} array of tokens
*/
function tokenizer( line ) {
	var tokens = [];

	parse( line, {
		'ecmaVersion': 'latest',
		'onToken': onToken,
		'onComment': onComment
	});

	/**
	* Callback for handling a `Token` event when parsing.
	*
	* @private
	* @param {Object} token - token object
	*/
	function onToken( token ) {
		var command;

		// Ignore non-existent tokens:
		if ( token.start === token.end ) {
			return;
		}
		if ( token.type.isLoop || ( token.type.label === 'name' && [ 'async', 'await' ].includes( token.value ) ) ) {
			// Asynchronous and looping keywords: `for`, `while`, `do`, `async`, `await`:
			token.type = 'loop';
			tokens.push( token );
			return;
		}
		if ( token.type.keyword || ( token.type.label === 'name' && token.value === 'let' ) ) {
			// Keywords: `function`, `import`, `var`, `const`, `let` etc.:
			token.type = 'keyword';
			tokens.push( token );
			return;
		}
		if ( token.type.label === 'string' || token.type.label === 'regexp' || token.type.label === 'template' ) {
			// Strings, regex expressions and template string literals:
			token.type = 'string';
			tokens.push( token );
			return;
		}
		if ( token.type.label === 'num' ) {
			// Numeric literals:
			token.type = 'number';
			tokens.push( token );
			return;
		}
		if ( token.type.label === 'name' ) {
			// REPL commands:
			for ( command of COMMANDS ) {
				if ( token.value === command[ 0 ] ) {
					token.type = 'command';
					tokens.push( token );
					return;
				}
			}
		}
	}

	/**
	* Callback for handling a `Comment` event when parsing.
	*
	* @private
	* @param {Object} block - true if the comment is a block comment, false if it is a line comment
	* @param {string} text - comment value
	* @param {number} start - start index
	* @param {number} end - end index
	*/
	function onComment( block, text, start, end ) {
		if ( block ) {
			// TODO: add support for highlighting multi-line comments.
			return;
		}
		tokens.push({
			'type': 'comment',
			'start': start,
			'end': end
		});
	}

	return tokens;
}


// EXPORTS //

module.exports = tokenizer;
