/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var parse = require( 'acorn-loose' ).parse;
var walk = require( 'acorn-walk' );
var linkedList = require( '@stdlib/utils/linked-list' );
var contains = require('@stdlib/array/base/assert/contains');
var resolveLocalScopes = require( './resolve_local_scopes.js' );
var resolveLocalScope = require( './resolve_local_scope.js' );
var commands = require( './commands.js' );


// VARIABLES //

var COMMANDS = commands();
var RE_PUNCTUATION = /(\{|\}|\[|\]|\(|\)|,|;|:|\.|\?|\?\.|=>|\.\.\.|`|\${)/;


// MAIN //

/**
* Tokenizes the input line based on ECMAScript specification.
*
* @private
* @name tokenizer
* @type {Function}
* @param {string} line - input line
* @param {Object} context - REPL context
* @returns {Array} array of tokens
*/
function tokenizer( line, context ) {
	var declarations;
	var VISITORS;
	var tokens = [];
	var ast;
	var i;

	// Parse the given line into tokens & comments...
	ast = parse( line, {
		'ecmaVersion': 'latest',
		'onToken': onToken,
		'onComment': onComment
	});

	// Resolve variable declarations from the given line as tokens...
	declarations = [];
	ast = resolveLocalScopes( ast, declarations );
	if ( declarations ) {
		for ( i = 0; i < declarations.length; i++ ) {
			if ( declarations[ i ].start === declarations[ i ].end ) {
				continue;
			}
			tokens.push({
				'type': 'name',
				'value': declarations[ i ].name,
				'start': declarations[ i ].start,
				'end': declarations[ i ].end
			});
		}
	}

	// Resolve identifiers from the given line as tokens...
	VISITORS = {
		'Identifier': Identifier,
		'MemberExpression': MemberExpression
	};
	walk.simple( ast, VISITORS );

	return tokens;

	/**
	* Callback invoked upon encountering a `Token` when parsing.
	*
	* @private
	* @param {Object} token - token object
	*/
	function onToken( token ) {
		// Ignore non-existent tokens:
		if ( token.start === token.end ) {
			return;
		}
		if ( token.type.isLoop || contains( [ 'if', 'else', 'switch', 'case', 'catch', 'finally', 'try' ], token.type.keyword ) ) {
			// Control flow keywords - `for`, `while`, `do`, `if`, `else` etc:
			token.type = 'control';
			tokens.push( token );
			return;
		}
		if ( contains( [ 'this', 'super' ], token.type.keyword ) ) {
			// Special identifiers - `this`, `super`:
			token.type = 'specialIdentifier';
			tokens.push( token );
			return;
		}
		if ( contains( [ 'null', 'true', 'false' ], token.type.keyword ) || ( token.type.label === 'name' && token.value === 'undefined' ) ) {
			// Built-in literals - `true`, `false`, `null`, `undefined`:
			token.type = 'literal';
			tokens.push( token );
			return;
		}
		if ( token.type.keyword || ( token.type.label === 'name' && contains( [ 'async', 'await', 'let' ], token.value ) ) ) {
			// Keywords - `function`, `import`, `var`, `const`, `let` etc.:
			token.type = 'keyword';
			tokens.push( token );
			return;
		}
		if ( token.type.label === 'string' || token.type.label === 'template' ) {
			// Strings and template string literals:
			token.type = 'string';
			tokens.push( token );
			return;
		}
		if ( token.type.label === 'regexp' ) {
			// Regex expressions:
			token.type = 'regexp';
			tokens.push( token );
			return;
		}
		if ( token.type.label === 'num' ) {
			// Numeric literals:
			token.type = 'number';
			tokens.push( token );
			return;
		}
		if ( token.type.binop || token.type.prefix || token.type.postfix || token.type.isAssign ) { // eslint-disable-line max-len
			// Operator symbols - `+`, `=`, `++` etc:
			token.type = 'operator';
			tokens.push( token );
			return;
		}
		if ( RE_PUNCTUATION.test( token.type.label ) ) {
			// Punctuation symbols - `,`, `(`, `;` etc:
			token.value = token.type.label;
			token.type = 'punctuation';
			tokens.push( token );
		}
	}

	/**
	* Callback invoked upon encountering a `Comment` when parsing.
	*
	* @private
	* @param {Object} block - true if the comment is a block comment, false if it is a line comment
	* @param {string} text - comment value
	* @param {number} start - start index
	* @param {number} end - end index
	*/
	function onComment( block, text, start, end ) {
		if ( block ) {
			// TODO: add support for highlighting multi-line comments.
			return;
		}
		tokens.push({
			'type': 'comment',
			'start': start,
			'end': end
		});
	}

	/**
	* Callback invoked upon encountering a `Identifier` AST node.
	*
	* @private
	* @param {Object} node - AST node
	*/
	function Identifier( node ) {
		var identifier;
		var command;
		var i;

		// If identifier is defined in the local scope, assume and treat it like a `variable` and push it as a token...
		if ( contains( resolveLocalScope( ast, node ), node.name ) ) {
			tokens.push({
				'value': node.name,
				'type': 'variable',
				'start': node.start,
				'end': node.end
			});
			return;
		}
		// If identifier is a REPL command, push it as a token...
		for ( i = 0; i < COMMANDS.length; i++ ) {
			command = COMMANDS[ i ];
			if ( node.name === command[ 0 ] ) {
				tokens.push( {
					'value': node.name,
					'type': 'command',
					'start': node.start,
					'end': node.end
				});
				return;
			}
		}
		// If identifier is in global context, push it as a token...
		identifier = context[ node.name ];
		if ( identifier ) {
			if ( contains( [ 'boolean', 'string', 'number' ], typeof identifier ) ) {
				tokens.push( {
					'value': node.name,
					'type': 'variable',
					'start': node.start,
					'end': node.end
				});
			} else {
				tokens.push( {
					'value': node.name,
					'type': typeof identifier,
					'start': node.start,
					'end': node.end
				});
			}
		}
	}

	/**
	* Callback invoked upon encountering a `MemberExpression` AST node.
	*
	* @private
	* @param {Object} node - AST node
	*/
	function MemberExpression( node ) {
		var properties = linkedList();
		var property;
		var obj;

		/**
		* Recursively traverses the `MemberExpression` node to populate the `properties` array.
		*
		* @private
		* @param {Object} node - node to be traversed
		*/
		function traverse( node ) {
			if ( node.object.type === 'Identifier' ) {
				// Reached a resolvable MemberExpression (a.b in a.b.c.d), save property(b) & object(a) and exit:
				properties.unshift( node.property );
				properties.unshift( node.object );
			} else if ( node.object.type === 'MemberExpression' ) {
				// Found node with another MemberExpression as object, save property and traverse it:
				properties.unshift( node.property );
				traverse( node.object );
			}
		}
		traverse( node );

		if ( !properties.first() ) {
			// Not an object:
			return;
		}
		// Enter first property's namespace as the first property is already getting tokenized by the `Identifier` handler:
		obj = context;
		properties = properties.iterator();
		obj = obj[ properties.next().value.name ];
		if ( !obj ) {
			// Object not defined in context:
			return;
		}
		property = properties.next();
		while ( !property.done ) {
			// Fetch identifier value from context:
			obj = obj[ property.value.name ];
			if ( !obj ) {
				break;
			}
			// Push token if identifier exists in context:
			if ( contains( [ 'boolean', 'string', 'number' ], typeof obj ) ) {
				tokens.push({
					'value': property.value.name,
					'type': 'variable',
					'start': property.value.start,
					'end': property.value.end
				});
			} else {
				tokens.push({
					'value': property.value.name,
					'type': typeof obj,
					'start': property.value.start,
					'end': property.value.end
				});
			}
			property = properties.next();
		}
	}
}


// EXPORTS //

module.exports = tokenizer;
