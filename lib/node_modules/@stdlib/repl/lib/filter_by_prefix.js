/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var startsWith = require( '@stdlib/string/starts-with' );
var lowercase = require( '@stdlib/string/lowercase' );


// VARIABLES //

var PENALTIES = {
	'wrong_case': -1, // Penalty for a matching character that is in the wrong case
	'not_start': -4, // Penalty if the first letter of the completion and input are different
	'gap_between': -8, // Penalty for a gap between matching characters of input in the completion
	'gap_beginning': -1, // Penalty for a gap, before a character from input is encountered
	'missing_char': -19 // Penalty for a character in input that doesn't exist in the completion (to tackle possible spelling mistakes)
};
var LENIENCY_FACTOR = 0.27; // Controls how lenient the algorithm is


// FUNCTIONS //

/**
* Callback to sort the results array in descending order of score, and in ascending order of item length when scores are equal.
*
* @private
* @param {Object} a - first object representing a completion's fuzzy score
* @param {Object} b - second object representing a completion's fuzzy score
* @returns {number} - comparison result for array sorting
*/
function sortClbk(a, b) {
	if (b.score === a.score) {
		return a.completion.length - b.completion.length;
	}
	return b.score - a.score;
}

/**
* Checks if the completion is a fuzzy match for the input and returns a score representing the extent of the match.
* Based on a penalty based scoring system that charges a penalty for unfavourable characteristics in the completion string that make it less ideal of a match to the input string.
*
* @private
* @param {string} completion - completion string
* @param {string} input - input string
* @returns {number} - a score (<=0) representing the extent of the match. Lower scores (negative) indicate a worse match. A score of 0 indicates a perfect match.
*
* @example
* // The following example demonstrates the penalty system.
* // The input `zz` is a substring of `pizza` in this case.
* // Penalties levied: not_start + ( 2 * gap_beginning )
* // worstScore: input.length * missing_char = -38 , LENIENCY_FACTOR = 0.27
* // Threshold: worstScore * LENIENCY_FACTOR = -10.26
* var score = fuzzyMatch( 'pizza', 'zz' );
* // returns -6.0
* // score >= Threshold, it's a fuzzy match.
*/
function fuzzyMatch( completion, input ) {
	var lastMatchedIndex;
	var foundFirstMatch;
	var completionIndex;
	var gapsBetween;
	var inputIndex;
	var worstScore;
	var score;

	worstScore = input.length * PENALTIES.missing_char;

	// If the input is an exact prefix of the completion, return a perfect score...
	if ( startsWith( completion, input ) ) {
		return 0;
	}
	// If the completion is shorter than the input, don't match...
	if ( completion.length < input.length ) {
		return worstScore;
	}
	// If the input is just a single character, don't try to fuzzy match...
	if ( input.length === 1 ) {
		return worstScore;
	}

	score = 0;
	inputIndex = 0;
	completionIndex = 0;
	lastMatchedIndex = -1; // buffer to store the index in the completion string where the last match was found
	gapsBetween = 0;
	foundFirstMatch = false; // flag that tracks if we have found a single character from the input in the completion, so that we can check for `gap_between` penalties

	// If the first character of the input and completion do not match, charge the penalty...
	if ( lowercase( input[inputIndex] ) !== lowercase( completion[completionIndex] ) ) { // eslint-disable-line max-len
		score += PENALTIES.not_start;
	}
	// Traverse the completion string looking for characters in the input (in the same order)
	while ( inputIndex < input.length && completionIndex < completion.length ) {
		if ( lowercase( input[inputIndex] ) === lowercase( completion[completionIndex] ) ) { // eslint-disable-line max-len
			// If we find an input character match in the completion, check if the case doesn't match and charge a penalty accordingly...
			if ( input[inputIndex] !== completion[completionIndex] ) {
				score += PENALTIES.wrong_case;
			}
			foundFirstMatch = true;
			lastMatchedIndex = completionIndex;
			score += gapsBetween * PENALTIES.gap_between;
			gapsBetween = 0;
			inputIndex += 1;
		} else if ( completionIndex + 1 === completion.length ) {
			// Failed to find the input character in the completion string after full traversal, charge a penalty and check for the next character in the input string from the buffer index in the completion
			score += PENALTIES.missing_char;
			gapsBetween = 0;
			inputIndex += 1;
			completionIndex = lastMatchedIndex + 1;
		} else if ( foundFirstMatch ) {
			// If input and completion character do not match in this iteration and atleast one input character has been found before, track the gaps till the next match
			gapsBetween += 1;
		} else {
			// If input and completion character do not match in the iteration and no input character is found yet, track the gaps till the first match
			score += PENALTIES.gap_beginning;
		}
		completionIndex += 1;

		// Check for early rejections...
		if ( score < LENIENCY_FACTOR * worstScore ) {
			return worstScore;
		}
	}

	// Charge penalty for the input characters that are still remaining but the completion string is fully checked for input characters (e.g., input: abcd, completion: xayzb, charge penalty for the remaining c and d )
	score += ( input.length - inputIndex ) * PENALTIES.missing_char;

	return score;
}


// MAIN //

/**
* Filters a list of strings based on a provided search string.
*
* @private
* @param {Array} out - output array
* @param {Array} arr - source array
* @param {string} str - string filter
* @returns {Array} output array
*/
function filterByPrefix( out, arr, str ) {
	var worstScore;
	var results;
	var score;
	var i;

	results = [];
	worstScore = str.length * PENALTIES.missing_char;
	for ( i = 0; i < arr.length; i++ ) {
		score = fuzzyMatch( arr[ i ], str );
		if ( score >= LENIENCY_FACTOR * worstScore ) {
			// If completion is a fuzzy match, push the score and completion string
			results.push({
				'completion': arr[ i ],
				'score': score
			});
		}
	}
	// Sort the results array in descending order of score, and in ascending order of item length when scores are equal
	results.sort( sortClbk );

	// Push resulting completions into the output array
	for ( i = 0; i < results.length; i++ ) {
		out.push( results[ i ].completion );
	}

	return out;
}


// EXPORTS //

module.exports = filterByPrefix;
