/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-underscore-dangle, no-invalid-this */

'use strict';

// MODULES //

var logger = require( 'debug' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var lowercase = require( '@stdlib/string/lowercase' );
var max = require( '@stdlib/stats/base/max' );
var floor = require( '@stdlib/math/base/special/floor' );
var repeat = require( '@stdlib/string/repeat' );
var startsWith = require( '@stdlib/string/starts-with' );
var isEmptyString = require( '@stdlib/assert/is-empty-string' ).isPrimitive;
var displayPrompt = require( './display_prompt.js' );
var commonPrefix = require( './longest_common_prefix.js' );


// VARIABLES //

var debug = logger( 'repl:completer:engine' );


// FUNCTIONS //

/**
* Returns length of a completion string.
*
* @private
* @param {string} completion string
* @returns {number} length of completion string
*/
function getLength( completion ) {
	return completion.length;
}

/**
* Checks if the completion string is not empty.
*
* @private
* @param {string} completion - completion string
* @returns {boolean} boolean indicating if completion is not an empty string
*/
function isNotEmptyString( completion ) {
	return !isEmptyString( completion );
}


// MAIN //

/**
* Constructor for creating a completer engine.
*
* @private
* @constructor
* @param {REPL} repl - REPL instance
* @param {Function} completer - function for generating possible completions
* @param {WritableStream} ostream - writable stream
* @returns {CompleterEngine} completer engine instance
*/
function CompleterEngine( repl, completer, ostream ) {
	if ( !(this instanceof CompleterEngine) ) {
		return new CompleterEngine( repl, completer, ostream );
	}
	debug( 'Creating a completer engine...' );

	// Cache a reference to the provided REPL instance:
	this.repl = repl;

	// Cache a reference to the readline interface:
	this._rli = repl._rli;

	// Cache a reference to the output writable stream:
	this._ostream = ostream;

	// Cache a reference to the provided completer;
	this._completer = completer;

	// Create a callback for processing completions:
	this._onCompletions = this._completionCallback();

	// Initialize a buffer containing the current line being processed:
	this._line = '';

	// Initialize a buffer containing the list of generated completions:
	this._completionsList = [];

	return this;
}

/**
* Returns a callback for processing completions.
*
* @private
* @name _completionCallback
* @memberof CompleterEngine.prototype
* @returns {Function} completion callback
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, '_completionCallback', function completionCallback() {
	var self = this;
	return clbk;

	/**
	* Callback invoked upon resolving potential completions.
	*
	* @private
	* @param {(Error|null)} error - error object
	* @param {Array} completions - completion results
	* @returns {void}
	*/
	function clbk( error, completions ) {
		var autoCompletion;

		// Check whether we encountered an error when generating completions...
		if ( error ) {
			debug( 'Encountered an error when generating completions.' );
			self._ostream.write( 'Error: couldn\'t generate tab completions' );
			return;
		}
		self._completionsList = completions[ 0 ].filter( isNotEmptyString ); // remove empty completions
		if ( self._completionsList.length === 0 ) {
			debug( 'No completions to display.' );
			return;
		}
		// Resolve a common prefix from the completion results:
		autoCompletion = commonPrefix( self._completionsList ); // e.g., [ 'back', 'background', 'backward' ] => 'back'

		// If the completion candidates have a possible auto-completion (ie. a common prefix longer than the input), auto-complete it...
		if ( autoCompletion !== '' && autoCompletion.length > completions[ 1 ].length ) {
			debug( 'Found an auto-completion candidate: %s', autoCompletion );

			// Clear the input line
			self._ostream.write( repeat( '\x08', completions[1].length ) );
			self._rli.line = self._rli.line.slice( self._rli.cursor );

			// Move the cursor to the start of the line
			self._rli.cursor = 0;

			// Write the auto-completion string
			self._rli.write( autoCompletion );

			return;
		}
		debug( 'No auto-completion candidate, displaying all possible completions.' );

		// Display completions:
		self._displayCompletions();

		// Re-display the prompt:
		displayPrompt( self.repl, true );
	}
});

/**
* Highlights the matching parts of the completions based on the current line.
*
* @private
* @name _highlightCompletions
* @memberof CompleterEngine.prototype
* @returns {Array<string>} array of highlighted completions
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, '_highlightCompletions', function highlightCompletions() {
	var self = this;

	return this._completionsList.map( function highlightCompletion( completion ) { // eslint-disable-line max-len
		var lastMatchedIndex = -1;
		var completionIndex = 0;
		var highlighted = '';
		var boldIndexes = []; // Buffer to store indexes of characters in completion string that needs to be highlighted
		var lineIndex = 0;
		var i;

		// If input is an exact prefix of completion, directly highlight the substring...
		if ( startsWith( completion, self._line ) ) {
			return '\x1b[1m' + completion.slice(0, self._line.length) + '\x1b[0m' + completion.slice(self._line.length);
		}

		// Store indexes of each matching character in the completion string in the buffer...
		while ( lineIndex < self._line.length && completionIndex < completion.length ) { // eslint-disable-line max-len
			if ( lowercase( completion[ completionIndex ] ) === lowercase( self._line[ lineIndex ] ) ) { // eslint-disable-line max-len
				boldIndexes.push(completionIndex);
				lastMatchedIndex = completionIndex;
				lineIndex += 1;
			} else if ( completionIndex + 1 === completion.length ) {
				lineIndex += 1;
				completionIndex = lastMatchedIndex + 1;
			}
			completionIndex += 1;
		}

		// Highlight stored indexes in the completion string:
		for ( i = 0; i < completion.length; i++ ) {
			if ( boldIndexes.includes( i ) ) {
				highlighted += '\x1b[1m' + completion[i] + '\x1b[0m';
			} else {
				highlighted += completion[ i ];
			}
		}
		return highlighted;
	});
});

/**
* Displays the completions to the output stream.
*
* @private
* @name _displayCompletions
* @memberof CompleterEngine.prototype
* @returns {void}
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, '_displayCompletions', function displayCompletions() {
	var highlightedCompletions;
	var completionsLength;
	var widthOfColumn;
	var whitespaces;
	var completion;
	var lineIndex;
	var columns;
	var output;
	var i;

	// Determine number of columns of completions that should be displayed to the output stream
	completionsLength = this._completionsList.map( getLength );
	widthOfColumn = max( completionsLength.length, completionsLength, 1 ) + 4; // 4 space padding
	columns = floor( this._ostream.columns / widthOfColumn ) || 1;

	// Highlight completions if operating in "terminal" mode...
	if ( this.repl._isTTY ) {
		highlightedCompletions = this._highlightCompletions();
	} else {
		highlightedCompletions = this._completionsList;
	}

	output = '\r\n';
	lineIndex = 0;
	whitespaces = 0;
	for ( i = 0; i < highlightedCompletions.length; i++ ) {
		completion = highlightedCompletions[ i ];
		if ( lineIndex === columns ) {
			// Reached end of column, enter next line:
			output += '\r\n';
			lineIndex = 0;
			whitespaces = 0;
		} else {
			// Fill the space to move to the next column:
			output += repeat( ' ', whitespaces );
		}
		// Add completion string to the column in output:
		output += completion;
		whitespaces = widthOfColumn - completionsLength[i];
		lineIndex += 1;
	}
	// Ensure a space between completions and the following prompt...
	if ( lineIndex !== 0 ) {
		output += '\r\n\r\n';
	}
	// Write completions to the output stream:
	this._ostream.write( output );
});

/**
* Callback which should be invoked **before** a "keypress" event is processed by a readline interface.
*
* @name beforeKeypress
* @memberof CompleterEngine.prototype
* @param {string} data - input data
* @param {Object} key - key object
* @returns {void}
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, 'beforeKeypress', function beforeKeypress() {
	var cursor;
	var line;
	var self = this;

	cursor = this._rli.cursor;
	line = this._rli.line;

	// Get the line before the cursor:
	this._line = line.slice( 0, cursor );

	// Pause the input stream before generating completions as the completer may be asynchronous...
	this._rli.pause();
	this._completer( this._line, function onCompletions( error, completions ) {
		self._onCompletions( error, completions );
		self._rli.resume();
	});
});


// EXPORTS //

module.exports = CompleterEngine;
