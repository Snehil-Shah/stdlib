/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-underscore-dangle, no-invalid-this */

'use strict';

// MODULES //

var logger = require( 'debug' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var max = require( '@stdlib/stats/base/max' );
var floor = require( '@stdlib/math/base/special/floor' );
var repeat = require( '@stdlib/string/repeat' );
var isEmptyString = require( '@stdlib/assert/is-empty-string' ).isPrimitive;
var displayPrompt = require( './display_prompt.js' );
var commonPrefix = require( './longest_common_prefix.js' );


// VARIABLES //

var debug = logger( 'repl:completer:engine' );


// FUNCTIONS //

/**
* Returns length of a completion string.
*
* @private
* @param {string} completion string
* @returns {number} length of completion string
*/
function getLength( completion ) {
	return completion.length;
}

/**
* Checks if the completion string is not empty.
*
* @private
* @param {string} completion - completion string
* @returns {boolean} boolean indicating if completion is not an empty string
*/
function isNotEmptyString( completion ) {
	return !isEmptyString( completion );
}


// MAIN //

/**
* Constructor for creating a completer engine.
*
* @private
* @constructor
* @param {REPL} repl - REPL instance
* @param {Function} completer - function for generating possible completions
* @param {WritableStream} ostream - writable stream
* @returns {CompleterEngine} completer engine instance
*/
function CompleterEngine( repl, completer, ostream ) {
	if ( !(this instanceof CompleterEngine) ) {
		return new CompleterEngine( repl, completer, ostream );
	}
	debug( 'Creating a completer engine...' );

	// Cache a reference to the provided REPL instance:
	this.repl = repl;

	// Cache a reference to the readline interface:
	this._rli = repl._rli;

	// Cache a reference to the output writable stream:
	this._ostream = ostream;

	// Cache a reference to the provided completer;
	this._completer = completer;

	// Create a callback for processing completions:
	this._onCompletions = this._completionCallback();

	// Initialize a buffer containing the current line being processed:
	this._line = '';

	// Initialize a buffer containing the list of generated completions:
	this._completionsList = [];

	return this;
}

/**
* Returns a callback for processing completions.
*
* @private
* @name _completionCallback
* @memberof CompleterEngine.prototype
* @returns {Function} completion callback
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, '_completionCallback', function completionCallback() {
	var self = this;
	return clbk;

	/**
	* Callback invoked upon resolving potential completions.
	*
	* @private
	* @param {(Error|null)} error - error object
	* @param {Array} completions - completion results
	* @returns {void}
	*/
	function clbk( error, completions ) {
		var autocompletionSubstring;
		var prefix;

		// Check whether we encountered an error when generating completions...
		if ( error ) {
			debug( 'Encountered an error when generating completions.' );
			self._ostream.write( 'Error: couldn\'t generate tab completions' );
			return;
		}
		self._completionsList = completions[0].filter( isNotEmptyString ); // remove empty completions
		if ( self._completionsList.length === 0 ) {
			debug( 'No completions to display.' );
			return;
		}
		// Resolve a common prefix from the completion results:
		prefix = commonPrefix( self._completionsList ); // e.g., [ 'back', 'background', 'backward' ] => 'back'

		// Extract auto-completion substring:
		autocompletionSubstring = prefix.substring( commonPrefix( prefix, completions[1] ).length ); // eslint-disable-line max-len

		// If the completion candidates have a possible auto-completion (ie. a common prefix longer than the input), auto-complete it...
		if ( autocompletionSubstring !== '' ) {
			debug( 'Found an auto-completion candidate: %s', prefix );
			self._rli.write( autocompletionSubstring );
			return;
		}
		debug( 'No auto-completion candidate, displaying all possible completions.' );

		// Display completions:
		self._displayCompletions();

		// Re-display the prompt:
		displayPrompt( self.repl, true );
	}
});

setNonEnumerableReadOnly( CompleterEngine.prototype, '_displayCompletions', function displayCompletions() {
	var completionsLength;
	var widthOfColumn;
	var whitespaces;
	var completion;
	var lineIndex;
	var columns;
	var output;
	var i;

	// Determine number of columns of completions that should be displayed to the output stream
	completionsLength = this._completionsList.map( getLength );
	widthOfColumn = max( completionsLength.length, completionsLength, 1 ) + 4; // 4 space padding
	columns = floor( this._ostream.columns / widthOfColumn ) || 1;

	output = '\r\n';
	lineIndex = 0;
	whitespaces = 0;
	for ( i = 0; i < this._completionsList.length; i++ ) {
		completion = this._completionsList[i];
		if ( lineIndex === columns ) {
			// Reached end of column, enter next line:
			output += '\r\n';
			lineIndex = 0;
			whitespaces = 0;
		} else {
			// Fill the space to move to the next column:
			output += repeat( ' ', whitespaces );
		}
		// Add completion string to the column in output:
		output += completion;
		whitespaces = widthOfColumn - completionsLength[i];
		lineIndex += 1;
	}
	// Ensure a space between completions and the following prompt...
	if ( lineIndex !== 0 ) {
		output += '\r\n\r\n';
	}
	// Write completions to the output stream:
	this._ostream.write( output );
});

setNonEnumerableReadOnly( CompleterEngine.prototype, 'beforeKeypress', function beforeKeypress() {
	var cursor;
	var input;
	var line;

	cursor = this._rli.cursor;
	line = this._rli.line;

	// Get the line before the cursor:
	input = line.slice( 0, cursor );

	// Pause the input stream before generating completions as the completer may be asynchronous...
	this._rli.pause();
	Promise.resolve( this._completer( input, this._onCompletions ) )
		.then( this._rli.resume.bind( this._rli ) );
});


// EXPORTS //

module.exports = CompleterEngine;
