/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-underscore-dangle, no-invalid-this */

'use strict';

// MODULES //

var readline = require( 'readline' );
var logger = require( 'debug' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var lowercase = require( '@stdlib/string/lowercase' );
var max = require( '@stdlib/stats/base/max' );
var floor = require( '@stdlib/math/base/special/floor' );
var ceil = require( '@stdlib/math/base/special/ceil' );
var repeat = require( '@stdlib/string/repeat' );
var replace = require( '@stdlib/string/replace' );
var contains = require( '@stdlib/array/base/assert/contains' );
var startsWith = require( '@stdlib/string/starts-with' );
var isEmptyString = require( '@stdlib/assert/is-empty-string' ).isPrimitive;
var commonPrefix = require( './longest_common_prefix.js' );


// VARIABLES //

var debug = logger( 'repl:completer:engine' );
var RE_ANSI = /[\u001B\u009B][[\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\d/#&.:=?%@~_]+)*|[a-zA-Z\d]+(?:;[-a-zA-Z\d/#&.:=?%@~_]*)*)?\u0007)|(?:(?:\d{1,4}(?:;\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]))/g; // eslint-disable-line no-control-regex


// FUNCTIONS //

/**
* Removes ANSI escape codes from a string.
*
* @private
* @param {string} str - input string
* @returns {string} string with ANSI escape codes removed
*/
function stripANSI( str ) {
	return replace( str, RE_ANSI, '' );
}


// MAIN //

/**
* Constructor for creating a completer engine.
*
* @private
* @constructor
* @param {REPL} repl - REPL instance
* @param {Function} completer - function for generating possible completions
* @param {WritableStream} ostream - writable stream
* @param {Function} ttyWrite - function to trigger the default behaviour of the keypress
* @returns {CompleterEngine} completer engine instance
*/
function CompleterEngine( repl, completer, ostream, ttyWrite ) {
	if ( !(this instanceof CompleterEngine) ) {
		return new CompleterEngine( repl, completer, ostream );
	}
	debug( 'Creating a completer engine...' );

	// Cache a reference to the provided REPL instance:
	this.repl = repl;

	// Cache a reference to the readline interface:
	this._rli = repl._rli;

	// Cache a reference to the output writable stream:
	this._ostream = ostream;

	// Cache a reference to the provided completer;
	this._completer = completer;

	// Cache a reference to the private readline interface `ttyWrite` to allow calling the method when wanting default behavior:
	this._ttyWrite = ttyWrite;

	// Cache a reference to the REPL settings to determine the type of completions:
	this._settings = repl._settings;

	// Create a callback for processing completions:
	this._onCompletions = this._completionCallback();

	// Initialize a buffer containing the input line being processed:
	this._inputLine = '';

	// Initialize a buffer containing the remaining line after cursor:
	this._remainingLine = '';

	// Initialize a buffer containing the list of generated completions:
	this._completionsList = [];

	// Initialize a buffer containing the list of highlighted completions:
	this._highlightedCompletions = [];

	// Initialize a buffer storing the completion output's dimensions and indexes:
	this._output = {};
	this._output.columns = -1;
	this._output.rows = -1;
	this._output.widthOfColumn = -1;
	this._output.completionsLength = [];
	this._output.index = -1; // track index of current completion

	return this;
}

/**
* Returns a callback for processing completions.
*
* @private
* @name _completionCallback
* @memberof CompleterEngine.prototype
* @returns {Function} completion callback
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, '_completionCallback', function completionCallback() {
	var self = this;
	return clbk;

	/**
	* Callback invoked upon resolving potential completions.
	*
	* @private
	* @param {(Error|null)} error - error object
	* @param {Array} completions - completion results
	* @returns {void}
	*/
	function clbk( error, completions ) {
		var autoCompletion;
		var i;

		// Check whether we encountered an error when generating completions...
		if ( error ) {
			debug( 'Encountered an error when generating completions.' );
			self._ostream.write( 'Error: couldn\'t generate tab completions' );

			// Resume the input stream:
			self._rli.resume();
			return;
		}
		// Remove empty completions:
		self._completionsList = [];
		for ( i = 0; i < completions[ 0 ].length; i++ ) {
			if ( !isEmptyString( completions[ 0 ][ i ] ) ) {
				self._completionsList.push( completions[ 0 ][ i ] );
			}
		}
		if ( self._completionsList.length === 0 ) {
			debug( 'No completions to display.' );

			// Resume the input stream:
			self._rli.resume();
			return;
		}
		// Resolve a common prefix from the completion results:
		autoCompletion = commonPrefix( self._completionsList ); // e.g., [ 'back', 'background', 'backward' ] => 'back'

		// If the completion candidates have a possible auto-completion (ie. a common prefix longer than the input), auto-complete it...
		if ( autoCompletion !== '' && autoCompletion.length > completions[ 1 ].length ) {
			debug( 'Found an auto-completion candidate: %s', autoCompletion );

			// Clear the input line
			self._ostream.write( repeat( '\x08', completions[1].length ) );
			self._rli.line = self._rli.line.slice( self._rli.cursor );

			// Move the cursor to the start of the line
			self._rli.cursor = 0;

			// Write the auto-completion string
			self._rli.write( autoCompletion );

			// Resume the input stream:
			self._rli.resume();
			return;
		}
		debug( 'No auto-completion candidate, displaying all possible completions.' );

		// Display completions:
		self._displayCompletions();
		self.repl._isNavigatingCompletions = true;

		// Resume the input stream:
		self._rli.resume();
	}
});

/**
* Highlights the matching parts of the completions based on the current line.
*
* @private
* @name _highlightCompletions
* @memberof CompleterEngine.prototype
* @returns {Array<string>} array of highlighted completions
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, '_highlightCompletions', function highlightCompletions() {
	var highlightedCompletions;
	var lastMatchedIndex;
	var completionIndex;
	var highlighted;
	var boldIndexes;
	var completion;
	var lineIndex;
	var i;
	var j;

	highlightedCompletions = [];
	for ( i = 0; i < this._completionsList.length; i++) {
		completion = this._completionsList[ i ];
		lastMatchedIndex = -1;
		completionIndex = 0;
		highlighted = '';
		boldIndexes = []; // Buffer to store indexes of characters in completion string that needs to be highlighted
		lineIndex = 0;

		// If input is an exact prefix of completion, directly highlight the substring...
		if ( startsWith( completion, this._inputLine ) ) {
			highlighted = '\u001b[1m' + completion.slice(0, this._inputLine.length) + '\u001b[0m' + completion.slice(this._inputLine.length);
		} else {
			// Store indexes of each matching character in the completion string in the buffer...
			while ( lineIndex < this._inputLine.length && completionIndex < completion.length ) { // eslint-disable-line max-len
				if ( lowercase( completion[ completionIndex ] ) === lowercase( this._inputLine[ lineIndex ] ) ) { // eslint-disable-line max-len
					boldIndexes.push( completionIndex );
					lastMatchedIndex = completionIndex;
					lineIndex += 1;
				} else if ( completionIndex + 1 === completion.length ) {
					lineIndex += 1;
					completionIndex = lastMatchedIndex + 1;
				}
				completionIndex += 1;
			}
			// Highlight stored indexes in the completion string:
			for ( j = 0; j < completion.length; j++ ) {
				if ( contains( boldIndexes, j ) ) {
					highlighted += '\u001b[1m' + completion[ j ] + '\u001b[0m';
				} else {
					highlighted += completion[ j ];
				}
			}
		}
		highlightedCompletions.push( highlighted );
	}
	return highlightedCompletions;
});

/**
* Displays the completions to the output stream.
*
* @private
* @name _displayCompletions
* @memberof CompleterEngine.prototype
* @returns {void}
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, '_displayCompletions', function displayCompletions() {
	var whitespaces;
	var completion;
	var lineIndex;
	var output;
	var i;

	// Determine number of columns of completions that should be displayed to the output stream
	this._output.completionsLength = [];
	for ( i = 0; i < this._completionsList.length; i++ ) {
		this._output.completionsLength.push( this._completionsList[ i ].length ); // eslint-disable-line max-len
	}
	this._output.widthOfColumn = max( this._output.completionsLength.length, this._output.completionsLength, 1 ) + 4; // eslint-disable-line max-len
	this._output.columns = floor( this._ostream.columns / this._output.widthOfColumn ) || 1; // eslint-disable-line max-len
	this._output.rows = ceil( this._completionsList.length / this._output.columns ); // eslint-disable-line max-len

	// Highlight completions if operating in "terminal" mode...
	if ( this.repl._isTTY ) {
		this._highlightedCompletions = this._highlightCompletions();
	} else {
		this._highlightedCompletions = this._completionsList;
	}

	output = '\r\n';
	lineIndex = 0;
	whitespaces = 0;
	for ( i = 0; i < this._highlightedCompletions.length; i++ ) {
		completion = this._highlightedCompletions[ i ];
		if ( lineIndex === this._output.columns ) {
			// Reached end of column, enter next line:
			output += '\r\n';
			lineIndex = 0;
			whitespaces = 0;
		} else {
			// Fill the space to move to the next column:
			output += repeat( ' ', whitespaces );
		}
		// Add completion string to the column in output:
		output += completion;
		whitespaces = this._output.widthOfColumn - this._output.completionsLength[ i ]; // eslint-disable-line max-len
		lineIndex += 1;
	}
	// Ensure a space between completions and the following prompt...
	if ( lineIndex !== 0 ) {
		output += '\r\n\r\n';
	}
	// Write completions to the output stream:
	this._ostream.write( output );

	// Bring the cursor back to the current line:
	readline.moveCursor( this._ostream, 0, -1 * ( 2 + this._output.rows ) );
	readline.cursorTo( this._ostream, this._rli.cursor + this.repl._inputPrompt.length - 1 ); // eslint-disable-line max-len
});

/**
* Re-displays the navigated completions to the output stream.
*
* @private
* @name _navigateCompletions
* @memberof CompleterEngine.prototype
* @returns {void}
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, '_navigateCompletions', function navigateCompletions() {
	var whitespaces;
	var completion;
	var lineIndex;
	var output;
	var i;

	// Clear current completions output:
	readline.clearScreenDown( this._ostream );

	// Create the completions output after navigation:
	output = '\r\n';
	lineIndex = 0;
	whitespaces = 0;
	for ( i = 0; i < this._highlightedCompletions.length; i++ ) {
		completion = this._highlightedCompletions[ i ];
		if ( lineIndex === this._output.columns ) {
			// Reached end of column, enter next line:
			output += '\r\n';
			lineIndex = 0;
			whitespaces = 0;
		} else {
			// Fill the space to move to the next column:
			output += repeat( ' ', whitespaces );
		}
		if ( i === this._output.index && this.repl._isTTY ) {
			completion = stripANSI( completion );
			completion = '\u001b[7m' + completion + '\u001b[27m';
		}
		// Add completion string to the column in output:
		output += completion;
		whitespaces = this._output.widthOfColumn - this._output.completionsLength[ i ]; // eslint-disable-line max-len
		lineIndex += 1;
	}
	// Ensure a space between completions and the following prompt...
	if ( lineIndex !== 0 ) {
		output += '\r\n\r\n';
	}
	// Write completions to the output stream:
	this._ostream.write( output );

	// Bring the cursor back to the current line:
	readline.moveCursor( this._ostream, 0, -1 * ( 2 + this._output.rows ) );
	readline.cursorTo( this._ostream, this.repl._inputPrompt.length - 1 );
	this._rli.cursor = 0;

	// Insert the current suggestion in the line, that the user navigates to:
	readline.clearLine( this._ostream, 1 );
	this._rli.line = '';
	this._rli.write( ( this._completionsList[ this._output.index ] || this._inputLine ) + this._remainingLine ); // eslint-disable-line max-len
});

/**
* Callback which should be invoked **before** a "keypress" event is processed by a readline interface.
*
* @name beforeKeypress
* @memberof CompleterEngine.prototype
* @param {string} data - input data
* @param {Object} key - key object
* @returns {void}
*/
setNonEnumerableReadOnly( CompleterEngine.prototype, 'beforeKeypress', function beforeKeypress( data, key ) {
	var cursor;
	var line;

	if ( !key ) {
		this._ttyWrite.call( this._rli, data, key );
		return;
	}
	// If the completions output is visible, allow navigating it...
	if ( this.repl._isNavigatingCompletions ) {
		if ( key.name === 'tab' ) {
			// Stop navigating and hide the completions output:
			readline.clearScreenDown( this._ostream );
			this.repl._isNavigatingCompletions = false;
			return;
		}
		if ( key.name === 'down' ) {
			// Move to the next row...
			if ( this._output.index === -1 ) {
				this._output.index = 0;
				this._navigateCompletions();
			} else if ( this._output.index + this._output.columns <= this._completionsList.length ) { // eslint-disable-line max-len
				this._output.index += this._output.columns;
				this._navigateCompletions();
			}
		} else if ( key.name === 'up' ) {
			// Move to the previous row or if already on the line, stop navigating and trigger default behaviour...
			if ( this._output.index === -1 ) {
				readline.clearScreenDown( this._ostream );
				this.repl._isNavigatingCompletions = false;
				this._ttyWrite.call( this._rli, data, key );
				return;
			}
			if ( this._output.index - this._output.columns >= 0 ) {
				this._output.index -= this._output.columns;
			} else {
				this._output.index = -1;
			}
			this._navigateCompletions();
		} else if ( key.name === 'left' ) {
			// Move back an index...
			if ( this._output.index > 0 ) {
				this._output.index -= 1;
			}
			this._navigateCompletions();
		} else if ( key.name === 'right' ) {
			// Move ahead an index...
			if ( this._output.index < this._completionsList.length - 1 ) {
				this._output.index += 1;
			}
			this._navigateCompletions();
		} else {
			// For any other keypress, stop navigating and continue default behaviour...
			readline.clearScreenDown( this._ostream );
			this.repl._isNavigatingCompletions = false;
			this._ttyWrite.call( this._rli, data, key );
		}
		return;
	}
	// For other keypresses, don't trigger TAB completions:
	if ( key.name !== 'tab' ) {
		this._ttyWrite.call( this._rli, data, key );
		return;
	}

	cursor = this._rli.cursor;
	line = this._rli.line;

	// Get the line before the cursor:
	this._inputLine = line.slice(0, cursor);

	// Get the line after the cursor:
	this._remainingLine = line.slice(cursor);

	// Pause the input stream before generating completions as the completer may be asynchronous...
	this._rli.pause();
	this._completer( this._inputLine, this._onCompletions, this._settings.fuzzyCompletions ); // eslint-disable-line max-len
});


// EXPORTS //

module.exports = CompleterEngine;
