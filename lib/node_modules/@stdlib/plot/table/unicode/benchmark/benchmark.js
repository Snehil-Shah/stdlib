/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var bench = require( '@stdlib/bench' );
var pkg = require( './../package.json' ).name;
var UnicodeTable = require( './../lib' );


// MAIN //

bench( pkg+'::instantiation', function benchmark( b ) {
	var v;
	var i;
	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v = new UnicodeTable();
		if ( !( v instanceof UnicodeTable ) ) {
			b.fail( 'should return an instance' );
		}
	}
	b.toc();
	if ( !( v instanceof UnicodeTable ) ) {
		b.fail( 'should return an instance' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::instantiation,no_new', function benchmark( b ) {
	var ctor;
	var v;
	var i;

	ctor = UnicodeTable;

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v = ctor();
		if ( !( v instanceof UnicodeTable ) ) {
			b.fail( 'should return an instance' );
		}
	}
	b.toc();
	if ( !( v instanceof UnicodeTable ) ) {
		b.fail( 'should return an instance' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::instantiation,data', function benchmark( b ) {
	var v;
	var i;

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v = new UnicodeTable( [ [ 1, 2, 3 ], [ 4, 5, 6 ] ] );
		if ( !( v instanceof UnicodeTable ) ) {
			b.fail( 'should return an instance' );
		}
	}
	b.toc();
	if ( !( v instanceof UnicodeTable ) ) {
		b.fail( 'should return an instance' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::instantiation,data,headers', function benchmark( b ) {
	var v;
	var i;

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v = new UnicodeTable( [ [ 1, 2, 3 ], [ 4, 5, 6 ] ], [ 'col1', 'col2', 'col3' ] );
		if ( !( v instanceof UnicodeTable ) ) {
			b.fail( 'should return an instance' );
		}
	}
	b.toc();
	if ( !( v instanceof UnicodeTable ) ) {
		b.fail( 'should return an instance' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::instantiation,data,options', function benchmark( b ) {
	var opts;
	var v;
	var i;

	opts = {
		'alignment': 'left',
		'borders': '1 2 3 4',
		'cellPadding': 2,
		'columnSeparator': 'None',
		'corners': '* * * *',
		'headerSeparator': '-',
		'joints': '* * * * *',
		'marginX': 2,
		'marginY': 4,
		'maxCellWidth': 10,
		'maxOutputWidth': 60,
		'rowSeparator': '_'
	};
	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v = new UnicodeTable( [ [ 1, 2, 3 ], [ 4, 5, 6 ] ], opts );
		if ( !( v instanceof UnicodeTable ) ) {
			b.fail( 'should return an instance' );
		}
	}
	b.toc();
	if ( !( v instanceof UnicodeTable ) ) {
		b.fail( 'should return an instance' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::instantiation,data,headers,options', function benchmark( b ) {
	var opts;
	var v;
	var i;

	opts = {
		'alignment': 'left',
		'borders': '1 2 3 4',
		'cellPadding': 2,
		'columnSeparator': 'None',
		'corners': '* * * *',
		'headerSeparator': '-',
		'joints': '* * * * *',
		'marginX': 2,
		'marginY': 4,
		'maxCellWidth': 10,
		'maxOutputWidth': 60,
		'rowSeparator': '_'
	};
	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v = new UnicodeTable( [ [ 1, 2, 3 ], [ 4, 5, 6 ] ], [ 'col1', 'col2', 'col3' ], opts );
		if ( !( v instanceof UnicodeTable ) ) {
			b.fail( 'should return an instance' );
		}
	}
	b.toc();
	if ( !( v instanceof UnicodeTable ) ) {
		b.fail( 'should return an instance' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:alignment', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		'left',
		'center',
		'right'
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.alignment = values[ i % values.length ];
		if ( typeof v.alignment !== 'string' ) {
			b.fail( 'should return a string' );
		}
	}
	b.toc();
	if ( typeof v.borders !== 'string' ) {
		b.fail( 'should return a string' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:borders', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		'1 2 3 4',
		'- | - |',
		'None'
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.borders = values[ i % values.length ];
		if ( typeof v.borders !== 'string' ) {
			b.fail( 'should return a string' );
		}
	}
	b.toc();
	if ( typeof v.borders !== 'string' ) {
		b.fail( 'should return a string' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:cellPadding', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		1,
		2,
		3
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.cellPadding = values[ i % values.length ];
		if ( typeof v.cellPadding !== 'number' ) {
			b.fail( 'should return a number' );
		}
	}
	b.toc();
	if ( typeof v.cellPadding !== 'number' ) {
		b.fail( 'should return a number' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:columnSeparator', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		'|',
		'None'
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.columnSeparator = values[ i % values.length ];
		if ( typeof v.columnSeparator !== 'string' ) {
			b.fail( 'should return a string' );
		}
	}
	b.toc();
	if ( typeof v.columnSeparator !== 'string' ) {
		b.fail( 'should return a string' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:corners', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		'1 2 3 4',
		'* * * *',
		'None'
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.corners = values[ i % values.length ];
		if ( typeof v.corners !== 'string' ) {
			b.fail( 'should return a string' );
		}
	}
	b.toc();
	if ( typeof v.corners !== 'string' ) {
		b.fail( 'should return a string' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:headerSeparator', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		'-',
		'None'
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.headerSeparator = values[ i % values.length ];
		if ( typeof v.headerSeparator !== 'string' ) {
			b.fail( 'should return a string' );
		}
	}
	b.toc();
	if ( typeof v.headerSeparator !== 'string' ) {
		b.fail( 'should return a string' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:joints', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		'1 2 3 4 5',
		'* * * * *',
		'None'
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.joints = values[ i % values.length ];
		if ( typeof v.joints !== 'string' ) {
			b.fail( 'should return a string' );
		}
	}
	b.toc();
	if ( typeof v.joints !== 'string' ) {
		b.fail( 'should return a string' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:marginX', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		0,
		1,
		2
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.marginX = values[ i % values.length ];
		if ( typeof v.marginX !== 'number' ) {
			b.fail( 'should return a number' );
		}
	}
	b.toc();
	if ( typeof v.marginX !== 'number' ) {
		b.fail( 'should return a number' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:marginY', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		0,
		1,
		2
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.marginY = values[ i % values.length ];
		if ( typeof v.marginY !== 'number' ) {
			b.fail( 'should return a number' );
		}
	}
	b.toc();
	if ( typeof v.marginY !== 'number' ) {
		b.fail( 'should return a number' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:maxCellWidth', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		10,
		20,
		30
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.maxCellWidth = values[ i % values.length ];
		if ( typeof v.maxCellWidth !== 'number' ) {
			b.fail( 'should return a number' );
		}
	}
	b.toc();
	if ( typeof v.maxCellWidth !== 'number' ) {
		b.fail( 'should return a number' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:maxOutputWidth', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		100,
		200,
		300
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.maxOutputWidth = values[ i % values.length ];
		if ( typeof v.maxOutputWidth !== 'number' ) {
			b.fail( 'should return a number' );
		}
	}
	b.toc();
	if ( typeof v.maxOutputWidth !== 'number' ) {
		b.fail( 'should return a number' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});

bench( pkg+'::set,get:rowSeparator', function benchmark( b ) {
	var values;
	var v;
	var i;

	values = [
		'-',
		'None'
	];
	v = new UnicodeTable();

	b.tic();
	for ( i = 0; i < b.iterations; i++ ) {
		v.rowSeparator = values[ i % values.length ];
		if ( typeof v.rowSeparator !== 'string' ) {
			b.fail( 'should return a string' );
		}
	}
	b.toc();
	if ( typeof v.rowSeparator !== 'string' ) {
		b.fail( 'should return a string' );
	}
	b.pass( 'benchmark finished' );
	b.end();
});
