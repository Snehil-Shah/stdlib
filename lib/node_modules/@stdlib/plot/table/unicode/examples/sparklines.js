/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

var randi = require( '@stdlib/random/base/discrete-uniform' );
var discreteUniform = require( '@stdlib/random/array/discrete-uniform' );
var filled2dBy = require( '@stdlib/array/base/filled2d-by' );
var ColumnChart = require( '@stdlib/plot/sparklines/unicode/column' );
var TristateChart = require( '@stdlib/plot/sparklines/unicode/tristate' );
var LineChart = require( '@stdlib/plot/sparklines/unicode/line' );
var stdout = require( '@stdlib/streams/node/stdout' );
var UnicodeTable = require( './../lib' );

// Generate some random data sets:
var x0 = discreteUniform( 10, 0, 100, {
	'dtype': 'float64'
});
var x1 = discreteUniform( 10, -1, 1, {
	'dtype': 'int8'
});
var x2 = discreteUniform( 10, 0, 100, {
	'dtype': 'float64'
});

// Create various sparkline charts:
var chart0 = new ColumnChart( x0, {
	'yMin': 0,
	'yMax': 100,
	'bufferSize': 10
});
var chart1 = new TristateChart( x1, {
	'bufferSize': 10
});
var chart2 = new LineChart( x2, {
	'yMin': 0,
	'yMax': 100,
	'bufferSize': 10
});

// Add the charts to a hash:
var charts = [
	chart0,
	chart1,
	chart2
];

// Define the number of table rows and columns:
var nrows = 3;
var ncols = 4;

// Define a callback for generating a data set:
function clbk( indices ) {
	if ( indices[ 1 ] < ncols-1 ) {
		return indices[ 0 ];
	}
	return charts[ indices[ 0 ] ].render();
}

// Create a data set:
var data = filled2dBy( [ nrows, ncols ], clbk );

// Define column headers:
var headers = [ 'Row', 'Col 1', 'Col 2', 'Sparkline' ];

// Create a table:
var table = new UnicodeTable( data, {
	'headers': headers,
	'rowSeparator': '-',
	'align': 'right',
	'marginLeft': 5
});

// Render the table:
var str = table.render();
stdout.write( str+'\n' );

// Compute the number of lines:
var N = str.split( '\n' ).length;

// Created a throttled event listener:
var listener = throttledListener( onUpdate, 250 );

// Listen for change events:
var i;
for ( i = 0; i < charts.length; i++ ) {
	charts[ i ].on( 'change', listener );
}

// Periodically update the sparkline charts with new data:
var id = setInterval( update, 1000 );

// After some time, stop updating and close:
setTimeout( onTimeout, 11000 );

function throttledListener( clbk, limit ) {
	var flg = false;
	return listener;

	function listener() {
		if ( flg ) {
			return;
		}
		flg = true;
		setTimeout( onTimeout, limit );
	}

	function onTimeout() {
		flg = false;
		clbk();
	}
}

function update() {
	// Push data to the individual charts:
	chart0.push( randi( 0, 100 ) );
	chart1.push( randi( -1, 1 ) );
	chart2.push( randi( 0, 100 ) );
}

function onUpdate() {
	var i;

	// Re-render the sparklines:
	for ( i = 0; i < charts.length; i++ ) {
		table.set( i, ncols-1, charts[ i ].render() );
	}
	// Remove the previously rendered table:
	clearPreviousLines( N );

	// Re-render the table:
	stdout.write( table.render()+'\n' );
}

function onTimeout() {
	clearInterval( id );
}

function clearPreviousLines( count ) {
	var i;
	for ( i = 0; i < count; i++ ) {
		stdout.write( '\x1b[F' ); // move cursor up one line
		stdout.write( '\x1b[2K' ); // clear entire line
	}
}
