/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var splitGraphemeClusters = require( '@stdlib/string/split-grapheme-clusters' );
var wcswidth = require( './wcswidth.js' ); // TODO: replace with string/base/wcswidth
var RE_ANSI = require( './ansi_regexp.js' ); // TODO: replace with regexp/ansi-escape-sequence


// FUNCTIONS //

/**
* Removes empty strings from a list of strings.
*
* @private
* @param {StringArray} arr - array of strings
* @returns {StringArray} mutated input array
*
* @example
* var arr = [ '', 'a', 'b', '', 'c', '' ];
*
* var out = compress( arr );
* // returns [ 'a', 'b', 'c' ]
*
* @example
* var arr = [ '', '' ];
*
* var out = compress( arr );
* // returns []
*/
function compress( arr ) { // TODO: consider make this an array/base utility (e.g., remove falsy values; array/base/remove-falsy?)
	var i;
	var j;

	j = 0;
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ] ) {
			arr[ j ] = arr[ i ];
			j += 1;
		}
	}
	arr.length = j;
	return arr;
}

/**
* Returns a mask indicating whether an element is an ANSI escape sequence.
*
* @private
* @param {StringArray} arr - array of strings
* @returns {NonNegativeIntegerArray} mask array
*/
function ansiMask( arr ) {
	var out;
	var i;

	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		out.push( ( RE_ANSI.test( arr[ i ] ) ) ? 1 : 0 );
	}
	return out;
}

/**
* Splits each string into individual grapheme clusters according to a provided mask array.
*
* @private
* @param {StringArray} arr - input array
* @param {NonNegativeIntegerArray} msk - mask array
* @returns {Array<Array>} output arrays
*/
function splitGraphemes( arr, msk ) {
	var tmp;
	var oa;
	var om;
	var i;
	var j;

	oa = [];
	om = [];
	for ( i = 0; i < arr.length; i++ ) {
		// Check whether the string is "masked"...
		if ( msk[ i ] === 1 ) {
			// Copy over without splitting into grapheme clusters...
			oa.push( arr[ i ] );
			om.push( msk[ i ] );
			continue;
		}
		tmp = splitGraphemeClusters( arr[ i ] );
		for ( j = 0; j < tmp.length; j++ ) {
			oa.push( tmp[ j ] );
			om.push( msk[ i ] );
		}
	}
	return [ oa, om ];
}

/**
* Computes column widths for a list of strings according to a provided mask array.
*
* @private
* @param {StringArray} arr - input array
* @param {NonNegativeIntegerArray} msk - mask array
* @returns {NonNegativeIntegerArray} list of column widths
*/
function computeWidths( arr, msk ) { // TODO: eventually make this into a separate string utility package
	var out;
	var i;

	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( msk[ i ] ) {
			out.push( 0 );
		} else {
			out.push( wcswidth( arr[ i ] ) );
		}
	}
	return out;
}

/**
* Computes the sum of an array according to a provided mask array.
*
* @private
* @param {NonNegativeIntegerArray} arr - input array
* @param {NonNegativeIntegerArray} msk - mask array
* @returns {NonNegativeInteger} sum
*/
function sum( arr, msk ) { // TODO: replace with blas/ext/base/* msk sum package
	var s;
	var i;

	s = 0;
	for ( i = 0; i < arr.length; i++ ) {
		if ( msk[ i ] === 0 ) {
			s += arr[ i ];
		}
	}
	return s;
}


// MAIN //

/**
* Normalizes data belonging to a single table cell.
*
* @private
* @param {string} value - input string
* @returns {Object} normalized results
*/
function normalize( value ) {
	var tmp;
	var msk;
	var w;

	// Split the formatted string according to whether a substring is an ANSI escape sequence:
	tmp = compress( value.split( RE_ANSI ) );

	// Create a mask array which flags whether a substring is an ANSI escape sequence:
	msk = ansiMask( tmp );

	// Expand each non-ANSI escape sequence into individual grapheme clusters:
	tmp = splitGraphemes( tmp, msk );

	// For each grapheme cluster, compute the number of columns that a symbol is expected to occupy when rendered to a terminal:
	w = computeWidths( tmp[ 0 ], tmp[ 1 ] );

	return {
		'value': value,
		'graphemes': tmp[ 0 ],
		'mask': tmp[ 1 ],
		'columnWidths': w,
		'width': sum( w, tmp[ 1 ] )
	};
}


// EXPORTS //

module.exports = normalize;
