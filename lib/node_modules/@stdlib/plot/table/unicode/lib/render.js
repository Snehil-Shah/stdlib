/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-invalid-this */

'use strict';

// MODULES //

var numelDimension = require( '@stdlib/ndarray/base/numel-dimension' );
var floor = require( '@stdlib/math/base/special/floor' );
var ceil = require( '@stdlib/math/base/special/ceil' );
var min = require( '@stdlib/math/base/special/fast/min' );
var zeros = require( '@stdlib/array/base/zeros' );
var ndarray = require( '@stdlib/ndarray/base/ctor' );
var repeat = require( '@stdlib/string/repeat' );
var format = require( '@stdlib/string/format' );


// FUNCTIONS //

/**
* Converts a one-dimensional array to a two-dimensional ndarray.
*
* @private
* @param {Collection} data - input data
* @returns {ndarray} two-dimensional ndarray
*/
function array2matrix( data ) {
	return new ndarray( 'generic', data, [ 1, data.length ], [ data.length, 1 ], 0, 'row-major' );
}

/**
* Resolves individual column widths based on table data and specified paddings.
*
* @private
* @param {NonNegativeInteger} nrows - number of table rows
* @param {NonNegativeInteger} ncols - number of table columns
* @param {ndarray} data - table data
* @param {(ndarray|null)} headers - table headers
* @param {NonNegativeIntegerArray} leftPadding - left padding
* @param {NonNegativeIntegerArray} rightPadding - right padding
* @returns {NonNegativeIntegerArray} column widths
*/
function columnWidths( nrows, ncols, data, headers, leftPadding, rightPadding ) { // eslint-disable-line max-len
	var lpad;
	var rpad;
	var out;
	var len;
	var M;
	var N;
	var v;
	var i;
	var j;

	M = leftPadding.length;
	N = rightPadding.length;

	out = zeros( ncols );
	if ( headers ) {
		for ( j = 0; j < ncols; j++ ) {
			lpad = leftPadding[ j%M ];
			rpad = rightPadding[ j%N ];
			v = headers.get( 0, j );
			len = lpad + v.length + rpad;
			if ( len > out[ j ] ) {
				out[ j ] = len;
			}
		}
	}
	for ( i = 0; i < nrows; i++ ) {
		for ( j = 0; j < ncols; j++ ) {
			lpad = leftPadding[ j%M ];
			rpad = rightPadding[ j%N ];
			v = data.get( i, j );
			len = lpad + v.length + rpad;
			if ( len > out[ j ] ) {
				out[ j ] = len;
			}
		}
	}
	return out;
}

/**
* Computes a column width.
*
* @private
* @param {NonNegativeInteger} ngraphemes - number of grapheme clusters
* @param {NonNegativeInteger} maxWidth - maximum column width (in units of grapheme clusters)
* @returns {NonNegativeInteger} width (in units of grapheme clusters)
*/
function columnWidth( ngraphemes, maxWidth ) {
	return min( ngraphemes, maxWidth );
}

/**
* Resolves the column indices at which to wrap table rows.
*
* @private
* @param {Object} ctx - context object
* @param {NonNegativeInteger} ctx.maxWidth - maximum table width (in units of grapheme clusters)
* @param {NonNegativeIntegerArray} ctx.columnWidths - column widths (in units of grapheme clusters)
* @param {NonNegativeIntegerArray} ctx.maxWidths - maximum column widths (in units of grapheme clusters)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeInteger} ctx.borderL - left border length (in units of grapheme clusters)
* @param {NonNegativeInteger} ctx.borderR - right border length (in units of grapheme clusters)
* @param {Object} ctx.columnSeparator - column separator
* @returns {(NonNegativeIntegerArray|Error)} list of column indices or an error
*/
function wrappedColumnIndices( ctx ) {
	var indices;
	var width;
	var ncols;
	var len;
	var mw;
	var w;
	var i;

	ncols = ctx.columnWidths.length;

	// Initialize an array of indices at which to wrap table rows:
	indices = [ 0 ];

	// Calculate fixed horizontal length:
	len = ctx.marginL + ctx.borderR + ctx.borderL + ctx.marginR;

	// Resolve the column breakpoints...
	width = 0;
	for ( i = 0; i < ncols; i++ ) {
		mw = ctx.maxWidths[ i%ctx.maxWidths.length ];
		w = columnWidth( ctx.columnWidths[ i ], mw );
		if ( w > ctx.maxWidth ) {
			// The column cannot be accommodated according to the current table configuration, as the column widths exceeds the maximum allowed table width...
			return new Error( format( 'invalid operation. The resolved column width for column %d exceeds the maximum allowed table width. Consider either increasing `maxWidth` or decreasing `maxCellWidth`. Maximum width: %d. Maximum cell width: %d. Column width: %d.', ctx.maxWidth, mw, ctx.columnWidths[ i ] ) );
		}
		width += w;

		// If the computed width exceeds the maximum table width, we need to wrap table rows to a new table...
		if ( width+len > ctx.maxWidth ) {
			indices.push( i );
			width = 0;
			continue;
		}
		// For all columns apart from the last (which has a border, not a column separator), include the width of the column separator...
		if ( i < ncols-1 ) {
			width += ctx.columnSeparator.length;
		}
	}
	// Include a final "index" to serve as the index upper bound:
	indices.push( ncols );

	return indices;
}

/**
* Renders a specified number of whitespace characters.
*
* @private
* @param {NonNegativeInteger} len - number of whitespace characters
* @returns {string} output string
*/
function renderWhitespace( len ) {
	return repeat( ' ', len );
}

/**
* Renders a vertical margin.
*
* @private
* @param {Array} out - output array
* @param {NonNegativeInteger} margin - vertical margin
* @returns {Array} output array
*/
function renderVerticalMargin( out, margin ) {
	var i;
	for ( i = 0; i < margin; i++ ) {
		out.push( '' );
	}
	return out;
}

/**
* Renders a table line.
*
* @private
* @param {NonNegativeInteger} start - starting column index (inclusive)
* @param {NonNegativeInteger} end - ending column index (exclusive)
* @param {Object} ch - line characters
* @param {Object} ctx - context object
* @param {NonNegativeIntegerArray} ctx.columnWidths - column widths (in units of grapheme clusters)
* @param {NonNegativeIntegerArray} ctx.maxWidths - maximum column widths (in units of grapheme clusters)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeInteger} ctx.borderL - left border length (in units of grapheme clusters)
* @param {NonNegativeInteger} ctx.borderR - right border length (in units of grapheme clusters)
* @param {string} ctx.jointL - left joint
* @param {string} ctx.jointM - middle joint
* @param {string} ctx.jointR - right joint
* @param {Object} ctx.columnSeparator - column separator
* @param {string} ctx.mode - horizontal separator mode
* @returns {string} rendered line
*/
function renderLine( start, end, ch, ctx ) {
	var hidx;
	var out;
	var mw;
	var w;
	var i;
	var j;

	// Initialize an index variable for determining how to handle horizontal separators:
	hidx = 0;

	// Render left margin:
	out = renderWhitespace( ctx.marginL );

	// Render left joint:
	if ( ctx.borderL > 0 ) {
		out += ctx.jointL;
		if ( ctx.mode === 'interpolate' ) {
			hidx += 1;
		}
	}
	// Render a table line...
	for ( i = start; i < end; i++ ) {
		// If columns are separated by a column separator, render the middle joint...
		if ( i > start && ctx.columnSeparator.length > 0 ) {
			out += ctx.jointM;
			if ( ctx.mode === 'interpolate' ) {
				hidx += 1;
			} else if ( ctx.mode === 'repeat' ) {
				hidx = 0;
			}
		}
		// Render as many of the line characters as can visually fit across a column...
		mw = ctx.maxWidths[ i%ctx.maxWidths.length ];
		w = columnWidth( ctx.columnWidths[ i ], mw );
		for ( j = 0; j < w; j++ ) {
			out += ch[ hidx%ch.length ];
			hidx += 1;
		}
	}
	// Render right joint:
	if ( ctx.borderR > 0 ) {
		out += ctx.jointR;
	}
	// Render right margin:
	out += renderWhitespace( ctx.marginR );

	return out;
}

/**
* Renders a data row.
*
* @private
* @param {NonNegativeInteger} row - row index
* @param {NonNegativeInteger} start - starting column index (inclusive)
* @param {NonNegativeInteger} end - ending column index (exclusive)
* @param {ndarray} data - table data
* @param {Object} ctx - context object
* @param {NonNegativeInteger} ctx.columnWidths - column widths (in units of grapheme clusters)
* @param {NonNegativeIntegerArray} ctx.maxWidths - maximum column widths (in units of grapheme clusters)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeIntegerArray} ctx.paddingL - left cell padding
* @param {NonNegativeIntegerArray} ctx.paddingR - right cell padding
* @param {Object} ctx.borderL - left border object
* @param {Object} ctx.borderR - right border object
* @param {Object} ctx.columnSeparator - column separator
* @param {StringArray} ctx.alignments - cell alignments
* @param {NonNegativeInteger} vidx - vertical line index
* @returns {string} rendered line
*/
function renderRow( row, start, end, data, ctx, vidx ) {
	var lpad;
	var rpad;
	var out;
	var len;
	var mw;
	var w;
	var d;
	var v;
	var i;

	// Render left margin:
	out = renderWhitespace( ctx.marginL );

	// Render left border:
	if ( ctx.borderL.length > 0 ) {
		out += ctx.borderL.graphemes[ vidx%ctx.borderL.length ];
	}
	for ( i = start; i < end; i++ ) {
		// Render column separator:
		if ( i > start && ctx.columnSeparator.length > 0 ) {
			out += ctx.columnSeparator.graphemes[ vidx%ctx.columnSeparator.length ]; // eslint-disable-line max-len
		}
		// Resolve cell paddings:
		lpad = ctx.paddingL[ i%ctx.paddingL.length ];
		rpad = ctx.paddingR[ i%ctx.paddingR.length ];

		// Render left cell padding:
		out += renderWhitespace( lpad );

		// Resolve cell data:
		v = data.get( row, i );
		len = v.length + lpad + rpad; // number of grapheme clusters

		// Determine whether we need to truncate rendered data:
		mw = ctx.maxWidths[ i%ctx.maxWidths.length ];
		w = ctx.columnWidths[ i ];
		if ( w > mw ) {
			// Truncate rendered data:
			w = mw;
			d = v.graphemes.slice( 0, mw-lpad-rpad ).join( '' );
		} else {
			d = v.value;
		}
		// Render cell contents:
		switch ( ctx.alignments[ i%ctx.alignments.length ] ) {
		case 'left':
			out += d;
			out += renderWhitespace( w-len );
			break;
		case 'center':
			out += renderWhitespace( ceil( (w-len)/2 ) );
			out += d;
			out += renderWhitespace( floor( (w-len)/2 ) );
			break;
		case 'right':
			out += renderWhitespace( w-len );
			out += d;
			break;
		default:
			break;
		}
		// Render right cell padding:
		out += renderWhitespace( rpad );
	}
	// Render right border:
	if ( ctx.borderR.length > 0 ) {
		out += ctx.borderR.graphemes[ vidx%ctx.borderR.length ];
	}
	// Render right margin:
	out += renderWhitespace( ctx.marginR );

	return out;
}


// MAIN //

/**
* Renders a table.
*
* @private
* @throws {Error} output must be able to accommodate every column individually
* @returns {string} rendered table
*/
function render() {
	var colWidths;
	var headers;
	var start;
	var nrows;
	var ncols;
	var vidx;
	var lctx;
	var rctx;
	var line;
	var end;
	var out;
	var idx;
	var i;
	var j;

	if ( this._data === null && this._headers === null ) {
		return '';
	}
	nrows = numelDimension( this._data, 0 );
	ncols = numelDimension( this._data, 1 );

	// Convert the list of headers to a two-dimensional ndarray:
	headers = ( this._headers ) ? array2matrix( this._headers ) : null;

	// Resolve the column widths needed to fit column data:
	colWidths = columnWidths( nrows, ncols, this._data, headers, this._paddingLeft, this._paddingRight ); // eslint-disable-line max-len

	// Resolve indices at which to wrap the table rows:
	idx = wrappedColumnIndices({
		'maxWidth': this._maxWidth,
		'columnWidths': colWidths,
		'maxWidths': this._maxCellWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'borderL': this._borders[ 3 ].length,
		'borderR': this._borders[ 1 ].length,
		'columnSeparator': this._columnSeparator
	});
	if ( idx instanceof Error ) {
		throw idx;
	}

	// Define a "line" context for rendering non-data content:
	lctx = {
		'columnWidths': colWidths,
		'maxWidths': this._maxCellWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'borderL': this._borders[ 3 ].length,
		'borderR': this._borders[ 1 ].length,
		'jointL': '',
		'jointM': '',
		'jointR': '',
		'columnSeparator': this._columnSeparator,
		'mode': this._horizontalSeparatorMode
	};

	// Define a "row" context for rendering column data:
	rctx = {
		'columnWidths': colWidths,
		'maxWidths': this._maxCellWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'paddingL': this._paddingLeft,
		'paddingR': this._paddingRight,
		'borderL': this._borders[ 3 ],
		'borderR': this._borders[ 1 ],
		'columnSeparator': this._columnSeparator,
		'alignments': this._align
	};

	// Initialize an array for pushing rendered lines:
	out = [];

	// Render top margin:
	out = renderVerticalMargin( out, this._margins[ 0 ] );

	// Render one or more tables...
	for ( j = 0; j < idx.length-1; j++ ) {
		start = idx[ j ];
		end = idx[ j+1 ];
		vidx = 0;

		// Render top border:
		if ( this._borders[ 0 ].length > 0 ) {
			lctx.jointL = this._corners[ 0 ].value;
			lctx.jointM = this._joints[ 1 ].value;
			lctx.jointR = this._corners[ 1 ].value;
			line = renderLine( start, end, this._borders[ 0 ].graphemes, lctx );
			out.push( line );
			if ( this._verticalSeparatorMode === 'interpolate' ) {
				vidx += 1;
			}
		}
		// Render headers:
		if ( this._headers ) {
			line = renderRow( 0, start, end, headers, rctx, vidx );
			out.push( line );
			vidx += 1;
		}
		// Render header separator:
		if ( this._headers && this._headerSeparator.length !== 0 ) {
			lctx.jointL = this._joints[ 4 ].value;
			lctx.jointM = this._joints[ 0 ].value;
			lctx.jointR = this._joints[ 2 ].value;
			line = renderLine( start, end, this._headerSeparator.graphemes, lctx ); // eslint-disable-line max-len
			out.push( line );
			if ( this._verticalSeparatorMode === 'interpolate' ) {
				vidx += 1;
			} else if ( this._verticalSeparatorMode === 'repeat' ) {
				vidx = 0;
			}
		}
		// Render table rows:
		if ( this._data ) {
			for ( i = 0; i < nrows; i++ ) {
				// Render a row of table data:
				line = renderRow( i, start, end, this._data, rctx, vidx );
				out.push( line );
				vidx += 1;

				// Render row separator:
				if ( this._rowSeparator.length > 0 && i < nrows-1 ) {
					lctx.jointL = this._joints[ 4 ].value;
					lctx.jointM = this._joints[ 0 ].value;
					lctx.jointR = this._joints[ 2 ].value;
					line = renderLine( start, end, this._rowSeparator.graphemes, lctx ); // eslint-disable-line max-len
					out.push( line );
					if ( this._verticalSeparatorMode === 'interpolate' ) {
						vidx += 1;
					} else if ( this._verticalSeparatorMode === 'repeat' ) {
						vidx = 0;
					}
				}
			}
		}
		// Render bottom border:
		if ( this._borders[ 2 ].length > 0 ) {
			lctx.jointL = this._corners[ 3 ].value;
			lctx.jointM = this._joints[ 3 ].value;
			lctx.jointR = this._corners[ 2 ].value;
			line = renderLine( start, end, this._borders[ 2 ].graphemes, lctx );
			out.push( line );
		}
	}
	// Render bottom margin:
	out = renderVerticalMargin( out, this._margins[ 2 ] );

	// Convert the output array to a newline-delimited string:
	out = out.join( '\n' );

	this.emit( 'render', out );
	return out;
}


// EXPORTS //

module.exports = render;
