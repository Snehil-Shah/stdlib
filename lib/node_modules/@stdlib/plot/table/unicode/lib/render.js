/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-invalid-this */

'use strict';

// MODULES //

var numelDimension = require( '@stdlib/ndarray/base/numel-dimension' );
var floor = require( '@stdlib/math/base/special/floor' );
var ceil = require( '@stdlib/math/base/special/ceil' );
var min = require( '@stdlib/math/base/special/fast/min' );
var max = require( '@stdlib/math/base/special/fast/max' );
var repeat = require( '@stdlib/string/repeat' );
var format = require( '@stdlib/string/format' );
var array2matrix = require( './array2matrix.js' );
var columnWidths = require( './column_widths.js' );


// FUNCTIONS //

/**
* Computes a column width.
*
* @private
* @param {NonNegativeInteger} len - number of character columns
* @param {NonNegativeInteger} maxWidth - maximum column width (in units of character columns)
* @returns {NonNegativeInteger} width (in units of character columns)
*/
function columnWidth( len, maxWidth ) {
	return min( len, maxWidth );
}

/**
* Resolves the column indices at which to wrap table rows.
*
* @private
* @param {Object} ctx - context object
* @param {NonNegativeInteger} ctx.maxWidth - maximum table width (in units of character columns)
* @param {Array<NonNegativeInteger|null>} ctx.fixedWidths - fixed column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.computedWidths - column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.maxColumnWidths - maximum column widths (in units of character columns)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeInteger} ctx.borderL - left border length (in units of character columns)
* @param {NonNegativeInteger} ctx.borderR - right border length (in units of character columns)
* @param {Object} ctx.columnSeparator - column separator
* @returns {(NonNegativeIntegerArray|Error)} list of column indices or an error
*/
function wrappedColumnIndices( ctx ) {
	var indices;
	var width;
	var ncols;
	var len;
	var mw;
	var fw;
	var w;
	var i;

	ncols = ctx.computedWidths.length;

	// Initialize an array of indices at which to wrap table rows:
	indices = [ 0 ];

	// Calculate fixed horizontal length:
	len = ctx.marginL + ctx.borderR + ctx.borderL + ctx.marginR;

	// Resolve the column breakpoints...
	width = 0;
	for ( i = 0; i < ncols; i++ ) {
		mw = ctx.maxColumnWidths[ i%ctx.maxColumnWidths.length ];
		fw = ctx.fixedWidths[ i%ctx.fixedWidths.length ];
		if ( fw === null ) {
			w = columnWidth( ctx.computedWidths[ i ], mw );
		} else {
			w = min( fw, mw );
		}
		if ( w > ctx.maxWidth ) {
			// The column cannot be accommodated according to the current table configuration, as the column widths exceeds the maximum allowed table width...
			return new Error( format( 'invalid operation. The resolved column width for column %d exceeds the maximum allowed table width. Consider either increasing `maxWidth` or decreasing `maxColumnWidth`. Maximum width: %d. Maximum cell width: %d. Column width: %d.', ctx.maxWidth, mw, ctx.computedWidths[ i ] ) );
		}
		width += w;

		// If the computed width exceeds the maximum table width, we need to wrap table rows to a new table...
		if ( width+len > ctx.maxWidth ) {
			indices.push( i );
			width = 0;
			continue;
		}
		// For all columns apart from the last (which has a border, not a column separator), include the width of the column separator...
		if ( i < ncols-1 ) {
			width += ctx.columnSeparator.width;
		}
	}
	// Include a final "index" to serve as the index upper bound:
	indices.push( ncols );

	return indices;
}

/**
* Joins a sequence of grapheme clusters according to an ANSI escape sequence mask array.
*
* @private
* @param {StringArray} arr - input array
* @param {NonNegativeIntegerArray} widths - grapheme cluster column widths
* @param {NonNegativeIntegerArray} msk - mask array
* @param {NonNegativeInteger} max - maximum output width
* @returns {Array<string|NonNegativeInteger>} output string and column width
*/
function join( arr, widths, msk, max ) {
	var width;
	var out;
	var w;
	var i;

	out = '';
	width = 0;
	for ( i = 0; i < arr.length; i++ ) {
		// Check whether the current element is an ANSI escape sequence...
		if ( msk[ i ] === 1 ) {
			// As ANSI escape sequences do not contribute to the visual width, we can just append to the output string without incrementing the output width...
			out += arr[ i ];
			continue;
		}
		// Avoid rendering an incomplete grapheme cluster and ensure that we do not exceed the maximum output width...
		w = widths[ i ];
		if ( width+w > max ) {
			break;
		}
		// The grapheme cluster can be completely rendered and is safe to include in the output string:
		out += arr[ i ];
		width += w;
	}
	// Append any remaining ANSI escape sequences in order to ensure that all matching resets are included in the output string...
	for ( ; i < arr.length; i++ ) {
		if ( msk[ i ] === 1 ) {
			out += arr[ i ];
		}
	}
	return [ out, width ];
}

/**
* Renders a specified number of whitespace characters.
*
* @private
* @param {NonNegativeInteger} len - number of whitespace characters
* @returns {string} output string
*/
function renderWhitespace( len ) {
	if ( len <= 0 ) {
		return '';
	}
	return repeat( ' ', len );
}

/**
* Renders a vertical margin.
*
* @private
* @param {Array} out - output array
* @param {NonNegativeInteger} margin - vertical margin
* @returns {Array} output array
*/
function renderVerticalMargin( out, margin ) {
	var i;
	for ( i = 0; i < margin; i++ ) {
		out.push( '' );
	}
	return out;
}

/**
* Renders a table line.
*
* @private
* @param {NonNegativeInteger} start - starting table column index (inclusive)
* @param {NonNegativeInteger} end - ending table column index (exclusive)
* @param {StringArray} ch - line characters
* @param {Object} ctx - context object
* @param {Array<NonNegativeInteger|null>} ctx.fixedWidths - fixed column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.computedWidths - column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.maxColumnWidths - maximum column widths (in units of character columns)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeInteger} ctx.borderL - left border length (in units of character columns)
* @param {NonNegativeInteger} ctx.borderR - right border length (in units of character columns)
* @param {string} ctx.jointL - left joint
* @param {string} ctx.jointM - middle joint
* @param {string} ctx.jointR - right joint
* @param {Object} ctx.columnSeparator - column separator
* @param {string} ctx.mode - horizontal separator mode
* @returns {string} rendered line
*/
function renderLine( start, end, ch, ctx ) {
	var hidx;
	var out;
	var mw;
	var fw;
	var w;
	var i;
	var j;

	// Initialize an index variable for determining how to handle horizontal separators:
	hidx = 0;

	// Render left margin:
	out = renderWhitespace( ctx.marginL );

	// Render left joint:
	if ( ctx.borderL > 0 ) {
		out += ctx.jointL;
		if ( ctx.mode === 'interpolate' ) {
			hidx += 1;
		}
	}
	// Render a table line...
	for ( i = start; i < end; i++ ) {
		// If columns are separated by a column separator, render the middle joint...
		if ( i > start && ctx.columnSeparator.width > 0 ) {
			out += ctx.jointM;
			if ( ctx.mode === 'interpolate' ) {
				hidx += 1;
			} else if ( ctx.mode === 'repeat' ) {
				hidx = 0;
			}
		}
		// Render as many of the line characters as can visually fit across a column...
		mw = ctx.maxColumnWidths[ i%ctx.maxColumnWidths.length ];
		fw = ctx.fixedWidths[ i%ctx.fixedWidths.length ];
		if ( fw === null ) {
			w = columnWidth( ctx.computedWidths[ i ], mw );
		} else {
			w = min( fw, mw );
		}
		for ( j = 0; j < w; j++ ) {
			out += ch[ hidx%ch.length ]; // WARNING: this assumes that each line character occupies a single column!
			hidx += 1;
		}
	}
	// Render right joint:
	if ( ctx.borderR > 0 ) {
		out += ctx.jointR;
	}
	// Render right margin:
	out += renderWhitespace( ctx.marginR );

	return out;
}

/**
* Renders a data row.
*
* @private
* @param {NonNegativeInteger} row - row index
* @param {NonNegativeInteger} start - starting column index (inclusive)
* @param {NonNegativeInteger} end - ending column index (exclusive)
* @param {ndarray} data - table data
* @param {Object} ctx - context object
* @param {Array<NonNegativeInteger|null>} ctx.fixedWidths - fixed column widths (in units of character columns)
* @param {NonNegativeInteger} ctx.computedWidths - column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.maxColumnWidths - maximum column widths (in units of character columns)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeIntegerArray} ctx.paddingL - left cell padding
* @param {NonNegativeIntegerArray} ctx.paddingR - right cell padding
* @param {Object} ctx.borderL - left border object
* @param {Object} ctx.borderR - right border object
* @param {Object} ctx.columnSeparator - column separator
* @param {StringArray} ctx.alignments - cell alignments
* @param {NonNegativeInteger} vidx - vertical line index
* @returns {string} rendered line
*/
function renderRow( row, start, end, data, ctx, vidx ) {
	var lpad;
	var rpad;
	var out;
	var len;
	var tmp;
	var mw;
	var fw;
	var w;
	var d;
	var v;
	var i;

	// Render left margin:
	out = renderWhitespace( ctx.marginL );

	// Render left border:
	if ( ctx.borderL.width > 0 ) {
		out += ctx.borderL.graphemes[ vidx%ctx.borderL.graphemes.length ];
	}
	for ( i = start; i < end; i++ ) {
		// Render column separator:
		if ( i > start && ctx.columnSeparator.width > 0 ) {
			out += ctx.columnSeparator.graphemes[ vidx%ctx.columnSeparator.graphemes.length ]; // eslint-disable-line max-len
		}
		// Resolve cell paddings:
		lpad = ctx.paddingL[ i%ctx.paddingL.length ];
		rpad = ctx.paddingR[ i%ctx.paddingR.length ];

		// Render left cell padding:
		out += renderWhitespace( lpad );

		// Resolve cell data:
		v = data.get( row, i );
		len = lpad + v.width + rpad; // number of character columns

		// Determine whether we need to truncate rendered data:
		mw = ctx.maxColumnWidths[ i%ctx.maxColumnWidths.length ];
		fw = ctx.fixedWidths[ i%ctx.fixedWidths.length ];
		w = ctx.computedWidths[ i ];
		if ( fw !== null ) {
			mw = min( fw, mw );
			w = max( fw, w );
		}
		if ( w > mw ) {
			// Truncate rendered data:
			w = mw;
			tmp = join( v.graphemes, v.columnWidths, v.mask, mw-lpad-rpad );
			d = tmp[ 0 ];
		} else {
			d = v.value;
		}
		// Render cell contents:
		switch ( ctx.alignments[ i%ctx.alignments.length ] ) {
		case 'left':
			out += d;
			out += renderWhitespace( w-len );
			break;
		case 'center':
			out += renderWhitespace( ceil( (w-len)/2 ) );
			out += d;
			out += renderWhitespace( floor( (w-len)/2 ) );
			break;
		case 'right':
			out += renderWhitespace( w-len );
			out += d;
			break;
		default:
			break;
		}
		// Render right cell padding:
		out += renderWhitespace( rpad );
	}
	// Render right border:
	if ( ctx.borderR.width > 0 ) {
		out += ctx.borderR.graphemes[ vidx%ctx.borderR.graphemes.length ];
	}
	// Render right margin:
	out += renderWhitespace( ctx.marginR );

	return out;
}


// MAIN //

/**
* Renders a table.
*
* @private
* @throws {Error} output must be able to accommodate every table column individually
* @returns {string} rendered table
*/
function render() {
	var computedWidths;
	var fixedWidths;
	var headers;
	var start;
	var nrows;
	var ncols;
	var vidx;
	var lctx;
	var rctx;
	var line;
	var end;
	var out;
	var idx;
	var tmp;
	var i;
	var j;

	if ( this._data === null && this._headers === null ) {
		return '';
	}
	nrows = numelDimension( this._data, 0 );
	ncols = numelDimension( this._data, 1 );

	// Convert the list of headers to a two-dimensional ndarray:
	headers = ( this._headers ) ? array2matrix( this._headers, [ 1, ncols ] ) : null; // eslint-disable-line max-len

	// Resolve the column widths needed to fit column data:
	computedWidths = columnWidths( nrows, ncols, this._data, headers, this._paddingLeft, this._paddingRight ); // eslint-disable-line max-len

	// Resolve fixed-width column widths:
	fixedWidths = this._columnWidth || [ null ];

	// Resolve the indices of columns at which to wrap table rows:
	idx = wrappedColumnIndices({
		'maxWidth': this._maxWidth,
		'fixedWidths': fixedWidths,
		'computedWidths': computedWidths,
		'maxColumnWidths': this._maxColumnWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'borderL': this._borders[ 3 ].width,
		'borderR': this._borders[ 1 ].width,
		'columnSeparator': this._columnSeparator
	});
	if ( idx instanceof Error ) {
		throw idx;
	}

	// Define a "line" context for rendering non-data content:
	lctx = {
		'fixedWidths': fixedWidths,
		'computedWidths': computedWidths,
		'maxColumnWidths': this._maxColumnWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'borderL': this._borders[ 3 ].width,
		'borderR': this._borders[ 1 ].width,
		'jointL': '',
		'jointM': '',
		'jointR': '',
		'columnSeparator': this._columnSeparator,
		'mode': this._horizontalSeparatorMode
	};

	// Define a "row" context for rendering column data:
	rctx = {
		'fixedWidths': fixedWidths,
		'computedWidths': computedWidths,
		'maxColumnWidths': this._maxColumnWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'paddingL': this._paddingLeft,
		'paddingR': this._paddingRight,
		'borderL': this._borders[ 3 ],
		'borderR': this._borders[ 1 ],
		'columnSeparator': this._columnSeparator,
		'alignments': this._align
	};

	// Initialize an array for pushing rendered lines:
	out = [];

	// Render top margin:
	out = renderVerticalMargin( out, this._margins[ 0 ] );

	// Render one or more tables...
	for ( j = 0; j < idx.length-1; j++ ) {
		start = idx[ j ];
		end = idx[ j+1 ];
		vidx = 0;

		// Render top border:
		if ( this._borders[ 0 ].width > 0 ) {
			lctx.jointL = this._corners[ 0 ].value;
			lctx.jointM = this._joints[ 1 ].value;
			lctx.jointR = this._corners[ 1 ].value;
			line = renderLine( start, end, this._borders[ 0 ].graphemes, lctx );
			out.push( line );
			if ( this._verticalSeparatorMode === 'interpolate' ) {
				vidx += 1;
			}
		}
		// Render headers:
		if ( this._headers ) {
			tmp = rctx.alignments;
			rctx.alignments = this._headerAlign || this._align;
			line = renderRow( 0, start, end, headers, rctx, vidx );
			out.push( line );
			vidx += 1;
			rctx.alignments = tmp;
		}
		// Render header separator:
		if ( this._headers && this._headerSeparator.width !== 0 ) {
			lctx.jointL = this._joints[ 4 ].value;
			lctx.jointM = this._joints[ 0 ].value;
			lctx.jointR = this._joints[ 2 ].value;
			line = renderLine( start, end, this._headerSeparator.graphemes, lctx ); // eslint-disable-line max-len
			out.push( line );
			if ( this._verticalSeparatorMode === 'interpolate' ) {
				vidx += 1;
			} else if ( this._verticalSeparatorMode === 'repeat' ) {
				vidx = 0;
			}
		}
		// Render table rows:
		if ( this._data ) {
			for ( i = 0; i < nrows; i++ ) {
				// Render a row of table data:
				line = renderRow( i, start, end, this._data, rctx, vidx );
				out.push( line );
				vidx += 1;

				// Render row separator:
				if ( this._rowSeparator.width > 0 && i < nrows-1 ) {
					lctx.jointL = this._joints[ 4 ].value;
					lctx.jointM = this._joints[ 0 ].value;
					lctx.jointR = this._joints[ 2 ].value;
					line = renderLine( start, end, this._rowSeparator.graphemes, lctx ); // eslint-disable-line max-len
					out.push( line );
					if ( this._verticalSeparatorMode === 'interpolate' ) {
						vidx += 1;
					} else if ( this._verticalSeparatorMode === 'repeat' ) {
						vidx = 0;
					}
				}
			}
		}
		// Render bottom border:
		if ( this._borders[ 2 ].width > 0 ) {
			lctx.jointL = this._corners[ 3 ].value;
			lctx.jointM = this._joints[ 3 ].value;
			lctx.jointR = this._corners[ 2 ].value;
			line = renderLine( start, end, this._borders[ 2 ].graphemes, lctx );
			out.push( line );
		}
	}
	// Render bottom margin:
	out = renderVerticalMargin( out, this._margins[ 2 ] );

	// Convert the output array to a newline-delimited string:
	out = out.join( '\n' );

	this.emit( 'render', out );
	return out;
}


// EXPORTS //

module.exports = render;
