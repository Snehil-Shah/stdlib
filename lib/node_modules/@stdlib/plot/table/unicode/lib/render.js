/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var format = require( '@stdlib/string/format' );
var repeat = require( '@stdlib/string/repeat' );
var floor = require( '@stdlib/math/base/special/floor' );
var ceil = require( '@stdlib/math/base/special/ceil' );
var min = require( '@stdlib/math/base/special/min' );
var slice = require( '@stdlib/array/slice' );
var truncate = require( '@stdlib/string/truncate' );


// MAIN //

/**
* Renders a table.
*
* @private
* @throws {Error} output must be able to accommodate every column individually
* @returns {string} rendered table
*/
function render() {
	/* eslint-disable no-invalid-this, no-underscore-dangle */
	var wrapIndices;
	var widths;
	var start;
	var table;
	var wraps;
	var self;
	var row;
	var end;
	var out;
	var i;
	var j;

	self = this;
	out = '';

	if ( !this._columnWidths ) {
		// Empty table:
		return out;
	}

	// Resolve indices to wrap the table at:
	wrapIndices = resolveWrapping();

	// Render top margin:
	out += repeat( '\n', this._marginY );

	// Render table:
	wraps = [];
	for ( j = 0; j < wrapIndices.length - 1; j++ ) {
		table = '';
		start = wrapIndices[ j ];
		end = wrapIndices[ j + 1 ];

		// Render top border:
		if ( this._borders !== 'None' ) {
			widths = slice( this._columnWidths, start, end );
			table += renderLine( this._borders[ 0 ], widths, this._corners[ 0 ], this._joints[ 1 ], this._corners[ 1 ] ); // eslint-disable-line max-len
			table += '\n';
		}

		// Render headers:
		if ( this._headers ) {
			row = slice( this._headers, start, end );
			widths = slice( this._columnWidths, start, end );
			table += renderRow( row, widths );
			table += '\n';
		}

		// Render header separator:
		if ( this._headers && this._headerSeparator !== 'None' ) {
			widths = slice( this._columnWidths, start, end );
			table += renderLine( this._headerSeparator, widths, this._joints[ 4 ], this._joints[ 0 ], this._joints[ 2 ] ); // eslint-disable-line max-len
			table += '\n';
		}

		// Render data:
		if ( this._data ) {
			for ( i = 0; i < this._data.length; i++ ) {
				// Render row:
				row = slice( this._data[ i ], start, end );
				widths = slice( this._columnWidths, start, end );
				table += renderRow( row, widths );
				if ( i !== this._data.length - 1 || this._borders !== 'None' ) {
					table += '\n';
				}
				// Render row separator:
				if ( this._rowSeparator !== 'None' && i !== this._data.length - 1 ) {
					widths = slice( this._columnWidths, start, end );
					table += renderLine( this._rowSeparator, widths, this._joints[ 4 ], this._joints[ 0 ], this._joints[ 2 ] ); // eslint-disable-line max-len
					table += '\n';
				}
			}
		}

		// Render bottom border:
		if ( this._borders !== 'None' ) {
			widths = slice( this._columnWidths, start, end );
			table += renderLine( this._borders[ 2 ], widths, this._corners[ 3 ], this._joints[ 3 ], this._corners[ 2 ] ); // eslint-disable-line max-len
		}
		wraps.push( table );
	}
	out += wraps.join( '\n' );

	// Render bottom margin:
	out += repeat( '\n', this._marginY );
	return out;

	/**
	* Resolves columns to wrap the table at (includes bounding indices).
	*
	* @private
	* @throws {Error} output must be able to accommodate every column individually
	* @returns {Array<number>} list of column indices
	*/
	function resolveWrapping() {
		var outputWidth;
		var fixedLength;
		var colWidth;
		var indices;

		// Initialize with zeroth index:
		indices = [ 0 ];

		// Calculate fixed horizontal length:
		fixedLength = 2 * self._marginX;
		if ( self._borders !== 'None' ) {
			fixedLength += 2;
		}
		outputWidth = 0;
		for ( i = 0; i < self._columnWidths.length; i++ ) {
			colWidth = min( self._columnWidths[ i ], self._maxCellWidth ); // width of current column
			outputWidth += colWidth + ( 2 * self._cellPadding );

			// If output crosses the maximum, time to wrap:
			if ( outputWidth + fixedLength > self._maxOutputWidth ) {
				if ( i === indices[ indices.length - 1 ] ) {
					// The output width cannot accommodate current column:
					throw new Error( format( 'invalid operation. `maxOutputWidth` must be able to accommodate every column individually. Value: `%s`', self._maxOutputWidth ) );
				}
				indices.push( i );
				outputWidth = 0;
				continue;
			}
			// Include column separator. Exclude for last column as we included them as borders:
			if ( i !== self._columnWidths.length - 1 && self._columnSeparator !== 'None' ) {
				outputWidth += 1;
			}
		}
		// Include last bounding index:
		indices.push( self._columnWidths.length );
		return indices;
	}

	/**
	* Renders a line.
	*
	* @private
	* @param {string} lineChar - line character
	* @param {Array<number>} columnWidths - column widths
	* @param {string} jointL - left joint
	* @param {string} jointM - middle joint
	* @param {jointR} jointR - right joint
	* @returns {string} rendered line
	*/
	function renderLine( lineChar, columnWidths, jointL, jointM, jointR ) {
		var colWidth;
		var out;
		var i;

		out = '';

		// Render left margin:
		out += repeat( ' ', self._marginX );

		// Render left joint:
		if ( self._borders !== 'None' ) {
			out += jointL;
		}
		// Render line:
		for ( i = 0; i < columnWidths.length; i++ ) {
			// If columns are separated, render the middle joint...
			if ( self._columnSeparator !== 'None' && i !== 0 ) {
				out += jointM;
			}
			colWidth = min( columnWidths[ i ], self._maxCellWidth );
			out += repeat( lineChar, colWidth + ( 2 * self._cellPadding ) );
		}
		// Render right joint:
		if ( self._borders !== 'None' ) {
			out += jointR;
		}
		// Render right margin:
		out += repeat( ' ', self._marginX );
		return out;
	}

	/**
	* Renders a data row.
	*
	* @private
	* @param {Array} data - row data
	* @param {Array<number>} columnWidths - column widths
	* @returns {string} rendered line
	*/
	function renderRow( data, columnWidths ) {
		var width;
		var datum;
		var out;
		var i;

		out = '';

		// Render left margin:
		out += repeat( ' ', self._marginX );

		// Render left border:
		if ( self._borders !== 'None' ) {
			out += self._borders[ 3 ];
		}
		for ( i = 0; i < columnWidths.length; i++ ) {
			// Render column separator...
			if ( self._columnSeparator !== 'None' && i !== 0 ) {
				out += self._columnSeparator;
			}
			// Render left cell padding:
			out += repeat( ' ', self._cellPadding );
			datum = String( data[ i ] );
			width = min( columnWidths[ i ], self._maxCellWidth );
			if ( datum.length > self._maxCellWidth ) {
				// Truncate long datum:
				datum = truncate( datum, self._maxCellWidth );
			}
			// Render datum:
			switch ( self._alignment ) {
			case 'left':
				out += datum;
				out += repeat( ' ', width - datum.length );
				break;
			case 'center':
				out += repeat( ' ', ceil( ( width - datum.length ) / 2 ) );
				out += datum;
				out += repeat( ' ', floor( ( width - datum.length ) / 2 ) );
				break;
			case 'right':
				out += repeat( ' ', width - datum.length );
				out += datum;
				break;
			default:
				break;
			}
			// Render right cell padding:
			out += repeat( ' ', self._cellPadding );
		}
		// Render right border:
		if ( self._borders !== 'None' ) {
			out += self._borders[ 1 ];
		}
		// Render right margin:
		out += repeat( ' ', self._marginX );
		return out;
	}
}


// EXPORTS //

module.exports = render;
