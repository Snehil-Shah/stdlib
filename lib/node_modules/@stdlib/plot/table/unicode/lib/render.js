/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-invalid-this */

'use strict';

// MODULES //

var numelDimension = require( '@stdlib/ndarray/base/numel-dimension' );
var floor = require( '@stdlib/math/base/special/floor' );
var ceil = require( '@stdlib/math/base/special/ceil' );
var min = require( '@stdlib/math/base/special/fast/min' );
var max = require( '@stdlib/math/base/special/fast/max' );
var repeat = require( '@stdlib/string/repeat' );
var format = require( '@stdlib/string/format' );
var array2matrix = require( './array2matrix.js' );
var columnWidths = require( './column_widths.js' );


// FUNCTIONS //

/**
* Computes a column width.
*
* @private
* @param {NonNegativeInteger} len - number of character columns
* @param {NonNegativeInteger} maxWidth - maximum column width (in units of character columns)
* @returns {NonNegativeInteger} width (in units of character columns)
*/
function columnWidth( len, maxWidth ) {
	return min( len, maxWidth );
}

/**
* Resolves the column indices at which to wrap table rows.
*
* @private
* @param {Object} ctx - context object
* @param {NonNegativeInteger} ctx.maxWidth - maximum table width (in units of character columns)
* @param {Array<NonNegativeInteger|null>} ctx.fixedWidths - fixed column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.computedWidths - column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.maxColumnWidths - maximum column widths (in units of character columns)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeInteger} ctx.borderL - left border length (in units of character columns)
* @param {NonNegativeInteger} ctx.borderR - right border length (in units of character columns)
* @param {Object} ctx.columnSeparator - column separator
* @returns {(NonNegativeIntegerArray|Error)} list of column indices or an error
*/
function wrappedColumnIndices( ctx ) {
	var indices;
	var width;
	var ncols;
	var len;
	var mw;
	var fw;
	var w;
	var i;

	ncols = ctx.computedWidths.length;

	// Initialize an array of indices at which to wrap table rows:
	indices = [ 0 ];

	// Calculate fixed horizontal length:
	len = ctx.marginL + ctx.borderR + ctx.borderL + ctx.marginR;

	// Resolve the column breakpoints...
	width = 0;
	for ( i = 0; i < ncols; i++ ) {
		mw = ctx.maxColumnWidths[ i%ctx.maxColumnWidths.length ];
		fw = ctx.fixedWidths[ i%ctx.fixedWidths.length ];
		if ( fw === null ) {
			w = columnWidth( ctx.computedWidths[ i ], mw );
		} else {
			w = min( fw, mw );
		}
		if ( w > ctx.maxWidth ) {
			// The column cannot be accommodated according to the current table configuration, as the column widths exceeds the maximum allowed table width...
			return new Error( format( 'invalid operation. The resolved column width for column %d exceeds the maximum allowed table width. Consider either increasing `maxWidth` or decreasing `maxColumnWidth`. Maximum width: %d. Maximum cell width: %d. Column width: %d.', ctx.maxWidth, mw, ctx.computedWidths[ i ] ) );
		}
		width += w;

		// If the computed width exceeds the maximum table width, we need to wrap table rows to a new table...
		if ( width+len > ctx.maxWidth ) {
			indices.push( i );
			width = 0;
			continue;
		}
		// For all columns apart from the last (which has a border, not a column separator), include the width of the column separator...
		if ( i < ncols-1 ) {
			width += ctx.columnSeparator.width;
		}
	}
	// Include a final "index" to serve as the index upper bound:
	indices.push( ncols );

	return indices;
}

/**
* Joins a sequence of grapheme clusters according to an ANSI escape sequence mask array.
*
* @private
* @param {StringArray} arr - input array
* @param {NonNegativeIntegerArray} widths - grapheme cluster column widths
* @param {NonNegativeIntegerArray} msk - mask array
* @param {NonNegativeInteger} skip - number of grapheme clusters to skip before starting to join subsequent grapheme clusters
* @param {NonNegativeInteger} max - maximum output width (inclusive)
* @returns {Array<string|NonNegativeInteger>} output string and column width
*/
function join( arr, widths, msk, skip, max ) {
	var width;
	var out;
	var cnt;
	var w;
	var i;

	out = '';
	width = 0;
	cnt = 0;
	for ( i = 0; i < arr.length; i++ ) {
		// Check whether the current element is an ANSI escape sequence...
		if ( msk[ i ] === 1 ) {
			// As ANSI escape sequences do not contribute to the visual width, we can just append to the output string without incrementing the output width...
			out += arr[ i ];
			continue;
		}
		// Avoid rendering an incomplete grapheme cluster and ensure that we do not exceed the maximum output width...
		w = widths[ i ];
		if ( width+w > max ) {
			break;
		}
		// Avoid rendering any grapheme clusters which should be skipped...
		if ( cnt < skip ) {
			cnt += 1;
			continue;
		}
		// The grapheme cluster can be completely rendered and is safe to include in the output string:
		out += arr[ i ];
		width += w;
	}
	// Append any remaining ANSI escape sequences in order to ensure that all matching resets are included in the output string...
	for ( ; i < arr.length; i++ ) {
		if ( msk[ i ] === 1 ) {
			out += arr[ i ];
		}
	}
	return [ out, width ];
}

/**
* Renders a specified number of whitespace characters.
*
* @private
* @param {NonNegativeInteger} len - number of whitespace characters
* @returns {string} output string
*/
function renderWhitespace( len ) {
	if ( len <= 0 ) {
		return '';
	}
	return repeat( ' ', len );
}

/**
* Renders a vertical margin.
*
* @private
* @param {Array} out - output array
* @param {NonNegativeInteger} margin - vertical margin
* @returns {Array} output array
*/
function renderVerticalMargin( out, margin ) {
	var i;
	for ( i = 0; i < margin; i++ ) {
		out.push( '' );
	}
	return out;
}

/**
* Renders a table line.
*
* @private
* @param {NonNegativeInteger} start - starting table column index (inclusive)
* @param {NonNegativeInteger} end - ending table column index (exclusive)
* @param {ObjectArray} ch - line characters
* @param {Object} ctx - context object
* @param {Array<NonNegativeInteger|null>} ctx.fixedWidths - fixed column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.computedWidths - column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.maxColumnWidths - maximum column widths (in units of character columns)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeInteger} ctx.borderL - left border length (in units of character columns)
* @param {NonNegativeInteger} ctx.borderR - right border length (in units of character columns)
* @param {Object} ctx.jointL - left joint
* @param {Object} ctx.jointM - middle joint
* @param {Object} ctx.jointR - right joint
* @param {Object} ctx.columnSeparator - column separator
* @param {string} ctx.mode - horizontal separator mode
* @returns {string} rendered line
*/
function renderLine( start, end, ch, ctx ) {
	var hidx;
	var out;
	var tmp;
	var mw;
	var fw;
	var w;
	var i;
	var j;

	// Initialize an index variable for determining how to handle horizontal separators:
	hidx = 0;

	// Render left margin:
	out = renderWhitespace( ctx.marginL );

	// Render left joint:
	if ( ctx.borderL > 0 ) {
		tmp = join( ctx.jointL.graphemes, ctx.jointL.columnWidths, ctx.jointL.mask, 0, 1 ); // eslint-disable-line max-len
		out += tmp[ 0 ];
		if ( ctx.mode === 'interpolate' ) {
			hidx += 1;
		}
	}
	// Render a table line...
	for ( i = start; i < end; i++ ) {
		// If columns are separated by a column separator, render the middle joint...
		if ( i > start && ctx.columnSeparator.width > 0 ) {
			tmp = join( ctx.jointM.graphemes, ctx.jointM.columnWidths, ctx.jointM.mask, 0, 1 ); // eslint-disable-line max-len
			out += tmp[ 0 ];
			if ( ctx.mode === 'interpolate' ) {
				hidx += 1;
			} else if ( ctx.mode === 'repeat' ) {
				hidx = 0;
			}
		}
		// Render as many of the line characters as can visually fit across a column...
		mw = ctx.maxColumnWidths[ i%ctx.maxColumnWidths.length ];
		fw = ctx.fixedWidths[ i%ctx.fixedWidths.length ];
		if ( fw === null ) {
			w = columnWidth( ctx.computedWidths[ i ], mw );
		} else {
			w = min( fw, mw );
		}
		for ( j = 0; j < w; j++ ) {
			tmp = join( ch.graphemes, ch.columnWidths, ch.mask, hidx%ch.ngraphemes, 1 ); // eslint-disable-line max-len
			out += tmp[ 0 ];
			hidx += 1;
		}
	}
	// Render right joint:
	if ( ctx.borderR > 0 ) {
		tmp = join( ctx.jointR.graphemes, ctx.jointR.columnWidths, ctx.jointR.mask, 0, 1 ); // eslint-disable-line max-len
		out += tmp[ 0 ];
	}
	// Render right margin:
	out += renderWhitespace( ctx.marginR );

	return out;
}

/**
* Renders a data row.
*
* @private
* @param {NonNegativeInteger} row - row index
* @param {NonNegativeInteger} start - starting column index (inclusive)
* @param {NonNegativeInteger} end - ending column index (exclusive)
* @param {ndarray} data - table data
* @param {Object} ctx - context object
* @param {Array<NonNegativeInteger|null>} ctx.fixedWidths - fixed column widths (in units of character columns)
* @param {NonNegativeInteger} ctx.computedWidths - column widths (in units of character columns)
* @param {NonNegativeIntegerArray} ctx.maxColumnWidths - maximum column widths (in units of character columns)
* @param {NonNegativeInteger} ctx.marginL - left table margin
* @param {NonNegativeInteger} ctx.marginR - right table margin
* @param {NonNegativeIntegerArray} ctx.paddingL - left cell padding
* @param {NonNegativeIntegerArray} ctx.paddingR - right cell padding
* @param {Object} ctx.borderL - left border object
* @param {Object} ctx.borderR - right border object
* @param {Object} ctx.columnSeparator - column separator
* @param {StringArray} ctx.alignments - cell alignments
* @param {NonNegativeInteger} vidx - vertical line index
* @returns {string} rendered line
*/
function renderRow( row, start, end, data, ctx, vidx ) {
	var lpad;
	var rpad;
	var out;
	var len;
	var tmp;
	var mw;
	var fw;
	var w;
	var d;
	var n;
	var v;
	var i;

	// Render left margin:
	out = renderWhitespace( ctx.marginL );

	// Render left border:
	if ( ctx.borderL.width > 0 ) {
		tmp = join( ctx.borderL.graphemes, ctx.borderL.columnWidths, ctx.borderL.mask, vidx%ctx.borderL.ngraphemes, 1 ); // eslint-disable-line max-len
		out += tmp[ 0 ];
	}
	for ( i = start; i < end; i++ ) {
		// Render column separator:
		if ( i > start && ctx.columnSeparator.width > 0 ) {
			tmp = join( ctx.columnSeparator.graphemes, ctx.columnSeparator.columnWidths, ctx.columnSeparator.mask, vidx%ctx.columnSeparator.ngraphemes, 1 ); // eslint-disable-line max-len
			out += tmp[ 0 ];
		}
		// Resolve cell paddings:
		lpad = ctx.paddingL[ i%ctx.paddingL.length ];
		rpad = ctx.paddingR[ i%ctx.paddingR.length ];

		// Render left cell padding:
		out += renderWhitespace( lpad );

		// Resolve cell data:
		v = data.get( row, i );
		len = lpad + v.width + rpad; // number of character columns

		// Determine whether we need to truncate rendered data:
		mw = ctx.maxColumnWidths[ i%ctx.maxColumnWidths.length ];
		fw = ctx.fixedWidths[ i%ctx.fixedWidths.length ];
		w = ctx.computedWidths[ i ];
		if ( fw !== null ) {
			mw = min( fw, mw );
			w = max( fw, w );
		}
		if ( w > mw ) {
			// Truncate rendered data:
			n = mw - lpad - rpad;
			tmp = join( v.graphemes, v.columnWidths, v.mask, 0, n );
			w = mw + ( n - tmp[ 1 ] ); // adjusted by a fudge factor to allow additional whitespace padding to be rendered if we were unable to render a string having the full desired width
			d = tmp[ 0 ];
		} else {
			d = v.value;
		}
		// Render cell contents:
		switch ( ctx.alignments[ i%ctx.alignments.length ] ) {
		case 'left':
			out += d;
			out += renderWhitespace( w-len );
			break;
		case 'center':
			out += renderWhitespace( ceil( (w-len)/2 ) );
			out += d;
			out += renderWhitespace( floor( (w-len)/2 ) );
			break;
		case 'right':
			out += renderWhitespace( w-len );
			out += d;
			break;
		default:
			break;
		}
		// Render right cell padding:
		out += renderWhitespace( rpad );
	}
	// Render right border:
	if ( ctx.borderR.width > 0 ) {
		tmp = join( ctx.borderR.graphemes, ctx.borderR.columnWidths, ctx.borderR.mask, vidx%ctx.borderR.ngraphemes, 1 ); // eslint-disable-line max-len
		out += tmp[ 0 ];
	}
	// Render right margin:
	out += renderWhitespace( ctx.marginR );

	return out;
}


// MAIN //

/**
* Renders a table.
*
* @private
* @throws {Error} output must be able to accommodate every table column individually
* @returns {string} rendered table
*/
function render() {
	var computedWidths;
	var fixedWidths;
	var headers;
	var start;
	var nrows;
	var ncols;
	var vidx;
	var lctx;
	var rctx;
	var line;
	var end;
	var out;
	var idx;
	var tmp;
	var i;
	var j;

	if ( this._data === null && this._headers === null ) {
		return '';
	}
	nrows = numelDimension( this._data, 0 );
	ncols = numelDimension( this._data, 1 );

	// Convert the list of headers to a two-dimensional ndarray:
	headers = ( this._headers ) ? array2matrix( this._headers, [ 1, ncols ] ) : null; // eslint-disable-line max-len

	// Resolve the column widths needed to fit column data:
	computedWidths = columnWidths( nrows, ncols, this._data, headers, this._paddingLeft, this._paddingRight ); // eslint-disable-line max-len

	// Resolve fixed-width column widths:
	fixedWidths = this._columnWidth || [ null ];

	// Resolve the indices of columns at which to wrap table rows:
	idx = wrappedColumnIndices({
		'maxWidth': this._maxWidth,
		'fixedWidths': fixedWidths,
		'computedWidths': computedWidths,
		'maxColumnWidths': this._maxColumnWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'borderL': this._borders[ 3 ].width,
		'borderR': this._borders[ 1 ].width,
		'columnSeparator': this._columnSeparator
	});
	if ( idx instanceof Error ) {
		throw idx;
	}

	// Define a "line" context for rendering non-data content:
	lctx = {
		'fixedWidths': fixedWidths,
		'computedWidths': computedWidths,
		'maxColumnWidths': this._maxColumnWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'borderL': this._borders[ 3 ].width,
		'borderR': this._borders[ 1 ].width,
		'jointL': null,
		'jointM': null,
		'jointR': null,
		'columnSeparator': this._columnSeparator,
		'mode': this._horizontalSeparatorMode
	};

	// Define a "row" context for rendering column data:
	rctx = {
		'fixedWidths': fixedWidths,
		'computedWidths': computedWidths,
		'maxColumnWidths': this._maxColumnWidth,
		'marginL': this._margins[ 3 ],
		'marginR': this._margins[ 1 ],
		'paddingL': this._paddingLeft,
		'paddingR': this._paddingRight,
		'borderL': this._borders[ 3 ],
		'borderR': this._borders[ 1 ],
		'columnSeparator': this._columnSeparator,
		'alignments': this._align
	};

	// Initialize an array for pushing rendered lines:
	out = [];

	// Render top margin:
	out = renderVerticalMargin( out, this._margins[ 0 ] );

	// Render one or more tables...
	for ( j = 0; j < idx.length-1; j++ ) {
		start = idx[ j ];
		end = idx[ j+1 ];
		vidx = 0;

		// Render top border:
		if ( this._borders[ 0 ].width > 0 ) {
			lctx.jointL = this._corners[ 0 ];
			lctx.jointM = this._joints[ 1 ];
			lctx.jointR = this._corners[ 1 ];
			line = renderLine( start, end, this._borders[ 0 ], lctx );
			out.push( line );
			if ( this._verticalSeparatorMode === 'interpolate' ) {
				vidx += 1;
			}
		}
		// Render headers:
		if ( this._headers ) {
			tmp = rctx.alignments;
			rctx.alignments = this._headerAlign || this._align;
			line = renderRow( 0, start, end, headers, rctx, vidx );
			out.push( line );
			vidx += 1;
			rctx.alignments = tmp;
		}
		// Render header separator:
		if ( this._headers && this._headerSeparator.width !== 0 ) {
			lctx.jointL = this._joints[ 4 ];
			lctx.jointM = this._joints[ 0 ];
			lctx.jointR = this._joints[ 2 ];
			line = renderLine( start, end, this._headerSeparator, lctx );
			out.push( line );
			if ( this._verticalSeparatorMode === 'interpolate' ) {
				vidx += 1;
			} else if ( this._verticalSeparatorMode === 'repeat' ) {
				vidx = 0;
			}
		}
		// Render table rows:
		if ( this._data ) {
			for ( i = 0; i < nrows; i++ ) {
				// Render a row of table data:
				line = renderRow( i, start, end, this._data, rctx, vidx );
				out.push( line );
				vidx += 1;

				// Render row separator:
				if ( this._rowSeparator.width > 0 && i < nrows-1 ) {
					lctx.jointL = this._joints[ 4 ];
					lctx.jointM = this._joints[ 0 ];
					lctx.jointR = this._joints[ 2 ];
					line = renderLine( start, end, this._rowSeparator, lctx );
					out.push( line );
					if ( this._verticalSeparatorMode === 'interpolate' ) {
						vidx += 1;
					} else if ( this._verticalSeparatorMode === 'repeat' ) {
						vidx = 0;
					}
				}
			}
		}
		// Render bottom border:
		if ( this._borders[ 2 ].width > 0 ) {
			lctx.jointL = this._corners[ 3 ];
			lctx.jointM = this._joints[ 3 ];
			lctx.jointR = this._corners[ 2 ];
			line = renderLine( start, end, this._borders[ 2 ], lctx );
			out.push( line );
		}
	}
	// Render bottom margin:
	out = renderVerticalMargin( out, this._margins[ 2 ] );

	// Convert the output array to a newline-delimited string:
	out = out.join( '\n' );

	this.emit( 'render', out );
	return out;
}


// EXPORTS //

module.exports = render;
