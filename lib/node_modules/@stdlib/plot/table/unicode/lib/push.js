/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-invalid-this */

'use strict';

// MODULES //

var isndarrayLike = require( '@stdlib/assert/is-ndarray-like' );
var isCollection = require( '@stdlib/assert/is-collection' );
var isPlainObjectArray = require( '@stdlib/assert/is-plain-object-array' );
var isObject = require( '@stdlib/assert/is-object' );
var ndarraylike2ndarray = require( '@stdlib/ndarray/base/ndarraylike2ndarray' );
var getShape = require( '@stdlib/ndarray/base/shape' );
var getStrides = require( '@stdlib/ndarray/base/strides' );
var getOffset = require( '@stdlib/ndarray/base/offset' );
var getOrder = require( '@stdlib/ndarray/base/order' );
var getDType = require( '@stdlib/ndarray/base/dtype' );
var getData = require( '@stdlib/ndarray/base/data-buffer' );
var emptyLike = require( '@stdlib/ndarray/empty-like' );
var expandDims = require( '@stdlib/ndarray/base/expand-dimensions' );
var ndarray = require( '@stdlib/ndarray/base/ctor' );
var assign = require( '@stdlib/ndarray/base/assign' );
var arrayShape = require( '@stdlib/array/shape' );
var format = require( '@stdlib/string/format' );
var convertDictionary = require( './convert_dictionary.js' );
var convertCollection = require( './convert_collection.js' );
var normalizeData = require( './normalize.js' );


// MAIN //

/**
* Appends one or more rows to table data.
*
* @private
* @param {(Object|Collection|VectorLike|MatrixLike)} data - row to add
* @throws {TypeError} must provide an object, an array-like object, a one-dimensional ndarray, or a two-dimensional ndarray
* @throws {RangeError} must provide the correct number of columns
* @returns {UnicodeTable} class instance
*/
function push( data ) {
	var headers;
	var view;
	var out;
	var arr;
	var tmp;
	var flg;
	var buf;
	var ash;
	var csh;
	var N;
	var i;
	var j;

	if ( isndarrayLike( data ) ) {
		arr = ndarraylike2ndarray( data );
		ash = getShape( arr, false );
		if ( ash.length > 2 ) {
			throw new TypeError( 'invalid argument. Input ndarray has too many dimensions. Must provide either a one-dimensional or a two-dimensional ndarray.' );
		}
		// Convert a one-dimensional ndarray to a two-dimensional ndarray...
		if ( ash.length === 1 ) {
			arr = expandDims( arr, 0 );
		}
		// Record that we have not yet copied the underlying data buffer:
		flg = false;
	}
	// If provided a collection, convert to an ndarray...
	else if ( isCollection( data ) ) {
		ash = arrayShape( data );

		// Check whether we were provided a one-dimensional array...
		if ( ash.length === 1 ) {
			if ( !isPlainObjectArray( data ) ) {
				// Assume that we were provided an array of column values belonging to a single row:
				data = [ data ];
			}
			// Otherwise, assume that we were provided a list of objects...
		}
		out = convertCollection( data, this.headers ); // NOTE: the use of `this.headers`, rather than `this._headers`, is intentional, as we only want the list of header values (if they exist)
		if ( out.code ) { // out.code === 'ERR_MISSING_COLUMNS'
			throw new TypeError( format( 'invalid argument. Must provide either an object, an array of column values, an array of objects, an array of arrays, a one-dimensional ndarray, or a two-dimensional ndarray. One or more of the provided data elements is missing expected column data. Expected columns: ["%s"]. Value: `%s`.', 'data', out.headers.join( '", "' ), JSON.stringify( data ) ) );
		}
		if ( out.headers ) {
			headers = out.headers;
		}
		arr = out.data; // ndarray

		// Record that we have copied provided table data to a new data buffer:
		flg = false;
	}
	// If provided anything else, try to either process as an object containing unordered column data or a dictionary of columns...
	else {
		out = convertDictionary( data, this.headers ); // NOTE: the use of `this.headers`, rather than `this._headers`, is intentional, as we only want the list of header values (if they exist)
		if ( out.code ) {
			// Ensure that we were provided an object...
			if ( !isObject( data ) ) {
				throw new TypeError( format( 'invalid argument. Must provide either an object, an array of column values, an array of objects, an array of arrays, a one-dimensional ndarray, or a two-dimensional ndarray. Value: `%s`.', JSON.stringify( data ) ) );
			}
			// If we failed to process as a dictionary of columns, attempt to process as a single object containing key-value pairs:
			tmp = convertCollection( [ data ], this.headers ); // NOTE: the use of `this.headers`, rather than `this._headers`, is intentional, as we only want the list of header values (if they exist)
			if ( tmp.code ) {
				if ( out.code === 'ERR_EMPTY_OBJECT' ) {
					throw new TypeError( format( 'invalid argument. Must provide either an object, an array of column values, an array of objects, an array of arrays, a one-dimensional ndarray, or a two-dimensional ndarray. Value: `%s`.', JSON.stringify( data ) ) );
				}
				if ( out.code === 'ERR_INVALID_OBJECT' ) {
					throw new TypeError( format( 'invalid argument. Must provide either an object, an array of objects, an array of arrays, or a two-dimensional ndarray. Value: `%s`.', JSON.stringify( data ) ) );
				}
				// out.code === 'ERR_UNEQUAL_COLUMN_LENGTHS'
				throw new TypeError( format( 'invalid argument. Must provide either an object, an array of column values, an array of objects, an array of arrays, a one-dimensional ndarray, or a two-dimensional ndarray. Each provided data column must have the same number of rows. Value: `%s`.', JSON.stringify( data ) ) );
			}
			// If we made it here, we were successful in treating the data as unordered column data:
			out = tmp;
		}
		if ( out.headers ) {
			headers = out.headers;
		}
		arr = out.data; // ndarray

		// Record that we have copied provided table data to a new data buffer:
		flg = false;
	}
	// Check whether to initialize table data...
	view = this._data;
	if ( view === null ) {
		this.data = arr;
		return;
	}
	// Ensure that the provided data does not have too many rows...
	ash = getShape( arr, false );
	if ( ash[ 0 ] > this._bufferSize ) {
		// In principle, we could apply the FIFO queue here, but, if a table is limited to, e.g., 5 rows and a user is providing 10 rows of data, they are probably doing something wrong...
		throw new RangeError( format( 'invalid argument. Input argument exceeds maximum data buffer size. Buffer size: %u. Number of rows: %u.', this._bufferSize, ash[ 0 ] ) );
	}
	// Ensure that the provided data has the expected number of columns...
	if ( ash[ 1 ] !== this._numColumns ) {
		throw new RangeError( format( 'invalid argument. Input argument must have %d columns in order to match the number of table columns. Number of columns: %u.', this._numColumns, ash[ 1 ] ) );
	}
	// If we have yet to copy provided table data to a new data buffer, do so now in order to prevent mutation of input data...
	if ( !flg ) {
		out = emptyLike( arr, {
			'dtype': 'generic'
		});
		assign( [ arr, out ] );
		arr = out;
	}
	// Normalize the incoming table data:
	normalizeData( getData( arr ) );

	// Get the current number of table rows and columns:
	csh = getShape( view );

	// Compute the number of combined rows based on the current number of table rows and the incoming data:
	N = csh[ 0 ] + ash[ 0 ];

	// If the number of combined rows exceeds the maximum buffer size, cap the number of rows to the buffer size limit...
	if ( N > this._bufferSize ) {
		N = this._bufferSize;
	}
	// Resolve the underlying FIFO queue:
	buf = getData( view );

	// Adjust the capacity of the underlying FIFO queue to accommodate table data:
	buf.resize( N * csh[1] );

	// Push provided data directly to the queue...
	for ( i = 0; i < ash[ 0 ]; i++ ) {
		for ( j = 0; j < ash[ 1 ]; j++ ) {
			buf.push( arr.get( i, j ) );
		}
	}
	// Create a new ndarray view atop the underlying FIFO queue:
	this._data = new ndarray( getDType( view ), buf, [ N, csh[1] ], getStrides( view, false ), getOffset( view ), getOrder( view ) ); // eslint-disable-line max-len

	if ( this._headers === null && headers !== void 0 ) {
		tmp = this._quiet;
		this._quiet = true; // avoid triggering a 'change' event
		this.headers = headers; // NOTE: assigning to `this.headers` is intentional in order to ensure proper processing of headers
		this._quiet = tmp;
	}
	if ( !this._quiet ) {
		this.emit( 'change' );
	}
	return this;
}


// EXPORTS //

module.exports = push;
