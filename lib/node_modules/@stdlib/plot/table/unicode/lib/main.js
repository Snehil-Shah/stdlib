/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var EventEmitter = require( 'events' ).EventEmitter;
var logger = require( 'debug' );
var setReadWriteAccessor = require( '@stdlib/utils/define-nonenumerable-read-write-accessor' );
var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var defineProperty = require( '@stdlib/utils/define-property' );
var objectKeys = require( '@stdlib/utils/keys' );
var inherit = require( '@stdlib/utils/inherit' );
var isObject = require( '@stdlib/assert/is-plain-object' );
var pick = require( '@stdlib/utils/pick' );
var format = require( '@stdlib/string/format' );
var setAlign = require( './props/align/set.js' );
var getAlign = require( './props/align/get.js' );
var setAutoRender = require( './props/auto-render/set.js' );
var getAutoRender = require( './props/auto-render/get.js' );
var setBorderTop = require( './props/border-top/set.js' );
var getBorderTop = require( './props/border-top/get.js' );
var setBorderRight = require( './props/border-right/set.js' );
var getBorderRight = require( './props/border-right/get.js' );
var setBorderBottom = require( './props/border-bottom/set.js' );
var getBorderBottom = require( './props/border-bottom/get.js' );
var setBorderLeft = require( './props/border-left/set.js' );
var getBorderLeft = require( './props/border-left/get.js' );
var setBorders = require( './props/borders/set.js' );
var getBorders = require( './props/borders/get.js' );
var setBufferSize = require( './props/buffer-size/set.js' );
var getBufferSize = require( './props/buffer-size/get.js' );
var setCornerTopLeft = require( './props/corner-top-left/set.js' );
var getCornerTopLeft = require( './props/corner-top-left/get.js' );
var setCornerTopRight = require( './props/corner-top-right/set.js' );
var getCornerTopRight = require( './props/corner-top-right/get.js' );
var setCornerBottomRight = require( './props/corner-bottom-right/set.js' );
var getCornerBottomRight = require( './props/corner-bottom-right/get.js' );
var setCornerBottomLeft = require( './props/corner-bottom-left/set.js' );
var getCornerBottomLeft = require( './props/corner-bottom-left/get.js' );
var setCorners = require( './props/corners/set.js' );
var getCorners = require( './props/corners/get.js' );
var setColumnSeparator = require( './props/column-separator/set.js' );
var getColumnSeparator = require( './props/column-separator/get.js' );
var setData = require( './props/data/set.js' );
var getData = require( './props/data/get.js' );
var setHeaders = require( './props/headers/set.js' );
var getHeaders = require( './props/headers/get.js' );
var setHeaderSeparator = require( './props/header-separator/set.js' );
var getHeaderSeparator = require( './props/header-separator/get.js' );
var setHorizontalSeparatorMode = require( './props/horizontal-separator-mode/set.js' ); // eslint-disable-line id-length
var getHorizontalSeparatorMode = require( './props/horizontal-separator-mode/get.js' ); // eslint-disable-line id-length
var setJointMiddle = require( './props/joint-middle/set.js' );
var getJointMiddle = require( './props/joint-middle/get.js' );
var setJointTop = require( './props/joint-top/set.js' );
var getJointTop = require( './props/joint-top/get.js' );
var setJointRight = require( './props/joint-right/set.js' );
var getJointRight = require( './props/joint-right/get.js' );
var setJointBottom = require( './props/joint-bottom/set.js' );
var getJointBottom = require( './props/joint-bottom/get.js' );
var setJointLeft = require( './props/joint-left/set.js' );
var getJointLeft = require( './props/joint-left/get.js' );
var setJoints = require( './props/joints/set.js' );
var getJoints = require( './props/joints/get.js' );
var setMarginTop = require( './props/margin-top/set.js' );
var getMarginTop = require( './props/margin-top/get.js' );
var setMarginRight = require( './props/margin-right/set.js' );
var getMarginRight = require( './props/margin-right/get.js' );
var setMarginBottom = require( './props/margin-bottom/set.js' );
var getMarginBottom = require( './props/margin-bottom/get.js' );
var setMarginLeft = require( './props/margin-left/set.js' );
var getMarginLeft = require( './props/margin-left/get.js' );
var setMargins = require( './props/margins/set.js' );
var getMargins = require( './props/margins/get.js' );
var setMaxCellWidth = require( './props/max-cell-width/set.js' );
var getMaxCellWidth = require( './props/max-cell-width/get.js' );
var setMaxWidth = require( './props/max-width/set.js' );
var getMaxWidth = require( './props/max-width/get.js' );
var setPaddingLeft = require( './props/padding-left/set.js' );
var getPaddingLeft = require( './props/padding-left/get.js' );
var setPaddingRight = require( './props/padding-right/set.js' );
var getPaddingRight = require( './props/padding-right/get.js' );
var setRowSeparator = require( './props/row-separator/set.js' );
var getRowSeparator = require( './props/row-separator/get.js' );
var setVerticalSeparatorMode = require( './props/vertical-separator-mode/set.js' );
var getVerticalSeparatorMode = require( './props/vertical-separator-mode/get.js' );
var defaults = require( './defaults.js' );
var render = require( './render.js' );
var push = require( './push.js' );
var getter = require( './get.js' );
var setter = require( './set.js' );


// VARIABLES //

var debug = logger( 'table:unicode:main' );

// List of private properties (note: keep in alphabetical order):
var PRIVATE_PROPS = [
	'_align',
	'_autoRender',
	'_borders',
	'_bufferSize',
	'_corners',
	'_columnSeparator',
	'_data',
	'_headers',
	'_headerSeparator',
	'_horizontalSeparatorMode',
	'_joints',
	'_margins',
	'_maxCellWidth',
	'_maxWidth',
	'_numColumns',
	'_paddingLeft',
	'_paddingRight',
	'_quiet',
	'_rowSeparator',
	'_verticalSeparatorMode'
];

// List of options properties (note: keep in alphabetical order):
var OPTIONS_PROPS = [
	'align',
	'autoRender',
	'borders',
	'bufferSize',
	'columnSeparator',
	'cornerBottomLeft',
	'cornerBottomRight',
	'corners',
	'cornerTopLeft',
	'cornerTopRight',
	'headers',
	'headerSeparator',
	'horizontalSeparatorMode',
	'jointBottomLeft',
	'jointBottomRight',
	'jointMiddle',
	'joints',
	'jointTopLeft',
	'jointTopRight',
	'marginBottom',
	'marginLeft',
	'marginRight',
	'marginTop',
	'margins',
	'maxCellWidth',
	'maxWidth',
	'paddingLeft',
	'paddingRight',
	'rowSeparator',
	'verticalSeparatorMode'
];


// FUNCTIONS //

/**
* Initializes private instance properties.
*
* @private
* @param {UnicodeTable} table - table instance
* @param {Object} defaults - default property values
* @returns {UnicodeTable} table instance
*/
function initializePrivateProperties( table, defaults ) { // eslint-disable-line id-length
	var i;

	for ( i = 0; i < PRIVATE_PROPS.length; i++ ) {
		defineProperty( table, PRIVATE_PROPS[ i ], {
			'configurable': false,
			'enumerable': false,
			'writable': true,
			'value': defaults[ PRIVATE_PROPS[ i ].substring( 1 ) ] || null
		});
	}
	return table;
}


// MAIN //

/**
* Unicode table constructor.
*
* @constructor
* @param {(Object|Collection<Object>|Collection<Collection>|MatrixLike)} [data] - table data
* @param {Options} [options] - table options
* @param {(Collection<string>|string)} [options.align='right'] - cell alignment(s)
* @param {boolean} [options.autoRender=false] - boolean indicating whether to re-render on each `change` event
* @param {string} [options.borderTop='-'] - top table border character(s)
* @param {string} [options.borderRight='|'] - right table border character(s)
* @param {string} [options.borderBottom='-'] - bottom table border character(s)
* @param {string} [options.borderLeft='|'] - left table border character(s)
* @param {Collection<string>} [options.borders=[ '─', '│', '─', '│' ]] - table border characters
* @param {(PositiveInteger|null)} [options.bufferSize] - size of data buffer
* @param {string} [options.columnSeparator='│'] - column separator character(s)
* @param {string} [options.cornerTopLeft='┌'] - top-left table corner grapheme cluster (i.e., visual character)
* @param {string} [options.cornerTopRight='┐'] - top-right table corner grapheme cluster (i.e., visual character)
* @param {string} [options.cornerBottomRight='┘''] - bottom-right table corner grapheme cluster (i.e., visual character)
* @param {string} [options.cornerBottomLeft='└'] - bottom-left table corner grapheme cluster (i.e., visual character)
* @param {Collection<string>} [options.corners=[ '┌', '┐', '┘', '└' ]] - table corner grapheme clusters (i.e., visual characters)
* @param {Collection} [options.headers] - table headers
* @param {string} [options.headerSeparator='─'] - header separator character(s)
* @param {string} [options.horizontalSeparatorMode='resume'] - horizontal line separator mode
* @param {string} [options.jointMiddle='┼'] - joint grapheme cluster (i.e., visual character) connecting cells within the middle of the table
* @param {string} [options.jointTop='┬'] - joint grapheme cluster (i.e., visual character) connecting cells along the top of the table
* @param {string} [options.jointRight='┤'] - joint grapheme cluster (i.e., visual character) connecting cells along the right side of the table
* @param {string} [options.jointBottom='┴'] - joint grapheme cluster (i.e., visual character) connecting cells along the bottom of the table
* @param {string} [options.jointLeft='├'] - joint grapheme cluster (i.e., visual character) connecting cells along the left side of the table
* @param {Collection<string>} [options.joints=[ '┼', '┬', '┤', '┴', '├' ]] - joint grapheme clusters (i.e., visual characters)
* @param {NonNegativeInteger} [options.marginTop=0] - margin at the top of the table in units of blank lines
* @param {NonNegativeInteger} [options.marginRight=0] - margin to the right of the table in units of whitespace
* @param {NonNegativeInteger} [options.marginBottom=0] - margin at the bottom of the table in units of blank lines
* @param {NonNegativeInteger} [options.marginLeft=0] - margin to the left of the table in units of whitespace
* @param {NonNegativeIntegerArray} [options.margins=[0, 0, 0, 0]] - table margins
* @param {(NonNegativeIntegerArray|NonNegativeInteger)} [options.maxCellWidth] - maximum cell width(s)
* @param {NonNegativeInteger} [options.maxWidth] - maximum table width
* @param {(NonNegativeIntegerArray|NonNegativeInteger)} [options.paddingLeft=1] - cell left padding in units of whitespace
* @param {(NonNegativeIntegerArray|NonNegativeInteger)} [options.paddingRight=1] - cell right padding in units of whitespace
* @param {string} [options.rowSeparator=''] - row separator character(s)
* @param {string} [options.verticalSeparatorMode='resume'] - vertical line separator mode
* @throws {TypeError} data argument must be an object, an array of objects, an array of arrays, or a two-dimensional ndarray
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {UnicodeTable} table instance
*
* @example
* var data = [ [ 1, 2 ], [ 3, 4 ] ];
* var headers = [ 'A', 'B' ];
*
* var table = UnicodeTable( data, {
*     'headers': headers
* });
*
* var str = table.render();
* // returns '...'
*/
function UnicodeTable() {
	var options;
	var nargs;
	var opts;
	var keys;
	var self;
	var key;
	var flg;
	var i;

	nargs = arguments.length;
	if ( !( this instanceof UnicodeTable ) ) {
		if ( nargs === 0 ) {
			return new UnicodeTable();
		}
		if ( nargs === 1 ) {
			return new UnicodeTable( arguments[ 0 ] );
		}
		return new UnicodeTable( arguments[ 0 ], arguments[ 1 ] );
	}
	// Initialize private instance properties:
	initializePrivateProperties( this, defaults() );
	this._quiet = false;

	// Resolve input arguments...
	if ( nargs === 0 ) {
		flg = false;
		options = {};
	} else if ( nargs === 1 ) {
		flg = true;
		options = {};
	} else {
		flg = true;
		options = arguments[ 1 ];
		if ( !isObject( options ) ) {
			throw new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );
		}
	}
	// Extract provided options while ignoring any extraneous/unsupported options properties:
	opts = pick( options, OPTIONS_PROPS );

	debug( 'Creating an instance with the following configuration: %s.', JSON.stringify( opts ) );

	// Validate provided options by assigning values to table properties...
	keys = objectKeys( opts );
	for ( i = 0; i < keys.length; i++ ) {
		key = keys[ i ];
		this[ key ] = opts[ key ];
	}
	// If we were provided a data argument, initialize table data...
	if ( flg ) {
		this.data = arguments[ 0 ];
	}
	// Add event listeners:
	this.on( 'change', onChange );
	this.on( 'render', onRender );

	self = this;
	return this;

	/**
	* Callback invoked upon receiving a `change` event.
	*
	* @private
	*/
	function onChange() {
		/* eslint-disable no-underscore-dangle */
		debug( 'Received a change event.' );
		if ( self._autoRender ) {
			self.render();
		}
	}

	/**
	* Callback invoked upon receiving a `render` event.
	*
	* @private
	* @param {string} table - rendered table
	*/
	function onRender() {
		debug( 'Received a render event.' );
	}
}

/*
* Inherit from the `EventEmitter` prototype.
*/
inherit( UnicodeTable, EventEmitter );

/**
* Alignment(s) of data within in each table cell.
*
* @name align
* @memberof UnicodeTable.prototype
* @type {(Array<string>|string)}
* @throws {TypeError} must be a supported alignment string or an array of alignment strings
* @default 'right'
*
* @example
* var table = new UnicodeTable();
*
* table.align = 'left';
*
* var align = table.align;
* // returns 'left'
*
* @example
* var table = new UnicodeTable();
*
* table.align = [ 'left', 'right', 'center' ];
*
* var align = table.align;
* // returns [ 'left', 'right', 'center' ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'align', getAlign, setAlign );

/**
* Rendering mode.
*
* ## Notes
*
* -   If `true`, an instance automatically re-renders a table on each `change` event.
*
* @name autoRender
* @memberof UnicodeTable.prototype
* @type {boolean}
* @throws {TypeError} must be a boolean
* @default false
*
* @example
* var table = new UnicodeTable();
*
* table.autoRender = true;
*
* var mode = table.autoRender;
* // returns true
*/
setReadWriteAccessor( UnicodeTable.prototype, 'autoRender', getAutoRender, setAutoRender );

/**
* Top table border character(s).
*
* @name borderTop
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '-'
*
* @example
* var table = new UnicodeTable();
*
* table.borderTop = '=';
*
* var border = table.borderTop;
* // returns '='
*/
setReadWriteAccessor( UnicodeTable.prototype, 'borderTop', getBorderTop, setBorderTop );

/**
* Right table border character(s).
*
* @name borderRight
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '-'
*
* @example
* var table = new UnicodeTable();
*
* table.borderRight = '|';
*
* var border = table.borderRight;
* // returns '|'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'borderRight', getBorderRight, setBorderRight );

/**
* Bottom table border character(s).
*
* @name borderBottom
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '-'
*
* @example
* var table = new UnicodeTable();
*
* table.borderBottom = '=';
*
* var border = table.borderBottom;
* // returns '='
*/
setReadWriteAccessor( UnicodeTable.prototype, 'borderBottom', getBorderBottom, setBorderBottom );

/**
* Left table border character(s).
*
* @name borderLeft
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '-'
*
* @example
* var table = new UnicodeTable();
*
* table.borderLeft = '|';
*
* var border = table.borderLeft;
* // returns '|'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'borderLeft', getBorderLeft, setBorderLeft );

/**
* Border characters in the order of `[top, right, bottom, left]`.
*
* @name borders
* @memberof UnicodeTable.prototype
* @type {Array<string>}
* @throws {TypeError} must be an array of four strings
* @default [ "─", "│", "─", "│" ]
*
* @example
* var table = new UnicodeTable();
*
* table.borders = [ '=', '!', '=', '!' ];
*
* var borders = table.borders;
* // returns [ '=', '!', '=', '!' ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'borders', getBorders, setBorders );

/**
* Size of internal data buffer.
*
* @name bufferSize
* @memberof UnicodeTable.prototype
* @type {(PositiveInteger|null)}
* @throws {TypeError} must be a positive integer or null
* @throws {RangeError} must be greater than or equal to the number of rows
*
* @example
* var table = new UnicodeTable();
*
* table.bufferSize = 20;
*/
setReadWriteAccessor( UnicodeTable.prototype, 'bufferSize', getBufferSize, setBufferSize );

/**
* Top-left table corner grapheme cluster (i.e., visual character).
*
* @name cornerTopLeft
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '┌'
*
* @example
* var table = new UnicodeTable();
*
* table.cornerTopLeft = '*';
*
* var corner = table.cornerTopLeft;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'cornerTopLeft', getCornerTopLeft, setCornerTopLeft );

/**
* Top-right table corner grapheme cluster (i.e., visual character).
*
* @name cornerTopRight
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '┐'
*
* @example
* var table = new UnicodeTable();
*
* table.cornerTopRight = '*';
*
* var corner = table.cornerTopRight;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'cornerTopRight', getCornerTopRight, setCornerTopRight );

/**
* Bottom-right table corner grapheme cluster (i.e., visual character).
*
* @name cornerBottomRight
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '┘'
*
* @example
* var table = new UnicodeTable();
*
* table.cornerBottomRight = '*';
*
* var corner = table.cornerBottomRight;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'cornerBottomRight', getCornerBottomRight, setCornerBottomRight );

/**
* Bottom-left table corner grapheme cluster (i.e., visual character).
*
* @name cornerBottomLeft
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '└'
*
* @example
* var table = new UnicodeTable();
*
* table.cornerBottomLeft = '*';
*
* var corner = table.cornerBottomLeft;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'cornerBottomLeft', getCornerBottomLeft, setCornerBottomLeft );

/**
* Table corner grapheme clusters (i.e., visual characters) in the order of `[top-left, top-right, bottom-right, bottom-left]`.
*
* @name corners
* @memberof UnicodeTable.prototype
* @type {Array<string>}
* @throws {TypeError} must be an array of four grapheme clusters
* @default [ "┌", "┐", "┘", "└" ]
*
* @example
* var table = new UnicodeTable();
*
* table.corners = [ '*', '*', '*', '*' ];
*
* var corners = table.corners;
* // returns [ '*', '*', '*', '*' ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'corners', getCorners, setCorners );

/**
* Column separator character(s).
*
* @name columnSeparator
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '│'
*
* @example
* var table = new UnicodeTable();
*
* table.columnSeparator = '$=';
*
* var separator = table.columnSeparator;
* // returns '$='
*/
setReadWriteAccessor( UnicodeTable.prototype, 'columnSeparator', getColumnSeparator, setColumnSeparator );

/**
* Table data.
*
* @name data
* @memberof UnicodeTable.prototype
* @type {ndarray}
* @throws {TypeError} must be an object, an array of objects, an array of arrays or a two-dimensional ndarray
* @throws {RangeError} must provide the correct number of columns
* @throws {RangeError} number of rows must not exceed the maximum data buffer size
*
* @example
* var ndarray2array = require( '@stdlib/ndarray/to-array' );
*
* var table = new UnicodeTable();
*
* table.data = [ [ 'a', 'b' ], [ 1, 2 ] ];
*
* var data = ndarray2array( table.data );
* // returns [ [ 'a', 'b' ], [ 1, 2 ] ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'data', getData, setData );

/**
* Table headers.
*
* @name headers
* @memberof UnicodeTable.prototype
* @type {Collection}
* @throws {TypeError} must be an array-like object
* @throws {RangeError} must provide the correct number of columns
*
* @example
* var table = new UnicodeTable();
*
* table.headers = [ 'name', 'age' ];
*
* var headers = table.headers;
* // returns [ 'name', 'age' ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'headers', getHeaders, setHeaders );

/**
* Header separator character(s).
*
* @name headerSeparator
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '─'
*
* @example
* var table = new UnicodeTable();
*
* table.headerSeparator = '$=';
*
* var separator = table.headerSeparator;
* // returns '$='
*/
setReadWriteAccessor( UnicodeTable.prototype, 'headerSeparator', getHeaderSeparator, setHeaderSeparator );

/**
* Horizontal line separator mode.
*
* @name horizontalSeparatorMode
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a supported line separator mode
* @default 'resume'
*
* @example
* var table = new UnicodeTable();
*
* table.horizontalSeparatorMode = 'repeat';
*
* var mode = table.horizontalSeparatorMode;
* // returns 'repeat'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'horizontalSeparatorMode', getHorizontalSeparatorMode, setHorizontalSeparatorMode );

/**
* Joint grapheme cluster (i.e., visual character) connecting cells within the middle of the table.
*
* @name jointMiddle
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '┼'
*
* @example
* var table = new UnicodeTable();
*
* table.jointMiddle = '*';
*
* var joint = table.jointMiddle;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'jointMiddle', getJointMiddle, setJointMiddle );

/**
* Joint grapheme cluster (i.e., visual character) connecting cells at the top of the table.
*
* @name jointTop
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '┬'
*
* @example
* var table = new UnicodeTable();
*
* table.jointTop = '*';
*
* var joint = table.jointTop;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'jointTop', getJointTop, setJointTop );

/**
* Joint grapheme cluster (i.e., visual character) connecting cells along the right side of the table.
*
* @name jointRight
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '┤'
*
* @example
* var table = new UnicodeTable();
*
* table.jointRight = '*';
*
* var joint = table.jointRight;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'jointRight', getJointRight, setJointRight );

/**
* Joint grapheme cluster (i.e., visual character) connecting cells at the bottom of the table.
*
* @name jointBottom
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '┴'
*
* @example
* var table = new UnicodeTable();
*
* table.jointBottom = '*';
*
* var joint = table.jointBottom;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'jointBottom', getJointBottom, setJointBottom );

/**
* Joint grapheme cluster (i.e., visual character) connecting cells along the left side of the table.
*
* @name jointLeft
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default '├'
*
* @example
* var table = new UnicodeTable();
*
* table.jointLeft = '*';
*
* var joint = table.jointLeft;
* // returns '*'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'jointLeft', getJointLeft, setJointLeft );

/**
* Joint grapheme clusters (i.e., visual characters) in the order of `[middle, top, right, bottom, left]`.
*
* @name joints
* @memberof UnicodeTable.prototype
* @type {Array<string>}
* @throws {TypeError} must be an array of five grapheme clusters
* @default [ "┼", "┬", "┤", "┴", "├" ]
*
* @example
* var table = new UnicodeTable();
*
* table.joints = [ '*', '*', '*', '*', '*' ];
*
* var joints = table.joints;
* // returns [ '*', '*', '*', '*', '*' ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'joints', getJoints, setJoints );

/**
* Margin at the top of the table in units of blank lines.
*
* @name marginTop
* @memberof UnicodeTable.prototype
* @type {NonNegativeInteger}
* @throws {TypeError} must be a nonnegative integer
* @default 0
*
* @example
* var table = new UnicodeTable();
*
* table.marginTop = 2;
*
* var margin = table.marginTop;
* // returns 2
*/
setReadWriteAccessor( UnicodeTable.prototype, 'marginTop', getMarginTop, setMarginTop );

/**
* Margin to the right of the table in units of whitespace.
*
* @name marginRight
* @memberof UnicodeTable.prototype
* @type {NonNegativeInteger}
* @throws {TypeError} must be a nonnegative integer
* @default 0
*
* @example
* var table = new UnicodeTable();
*
* table.marginRight = 2;
*
* var margin = table.marginRight;
* // returns 2
*/
setReadWriteAccessor( UnicodeTable.prototype, 'marginRight', getMarginRight, setMarginRight );

/**
* Margin at the bottom of the table in units of blank lines.
*
* @name marginBottom
* @memberof UnicodeTable.prototype
* @type {NonNegativeInteger}
* @throws {TypeError} must be a nonnegative integer
* @default 0
*
* @example
* var table = new UnicodeTable();
*
* table.marginBottom = 2;
*
* var margin = table.marginBottom;
* // returns 2
*/
setReadWriteAccessor( UnicodeTable.prototype, 'marginBottom', getMarginBottom, setMarginBottom );

/**
* Margin to the left of the table in units of whitespace.
*
* @name marginLeft
* @memberof UnicodeTable.prototype
* @type {NonNegativeInteger}
* @throws {TypeError} must be a nonnegative integer
* @default 0
*
* @example
* var table = new UnicodeTable();
*
* table.marginLeft = 2;
*
* var margin = table.marginLeft;
* // returns 2
*/
setReadWriteAccessor( UnicodeTable.prototype, 'marginLeft', getMarginLeft, setMarginLeft );

/**
* Table margins in order of `[top, right, bottom, left]`.
*
* @name margins
* @memberof UnicodeTable.prototype
* @type {NonNegativeIntegerArray}
* @throws {TypeError} must be an array of nonnegative integers
* @default [ 0, 0, 0, 0 ]
*
* @example
* var table = new UnicodeTable();
*
* table.margins = [ 2, 2, 2, 2 ];
*
* var margins = table.margins;
* // returns [ 2, 2, 2, 2 ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'margins', getMargins, setMargins );

/**
* Maximum cell width(s) in units of grapheme clusters (i.e., visual characters).
*
* @name maxCellWidth
* @memberof UnicodeTable.prototype
* @type {(Array<NonNegativeInteger|null>|NonNegativeInteger|null)}
* @throws {TypeError} must be a nonnegative integer, an array of nonnegative integers, or null
* @default +infinity
*
* @example
* var table = new UnicodeTable();
*
* table.maxCellWidth = 10;
*
* var width = table.maxCellWidth;
* // returns 10
*
* @example
* var table = new UnicodeTable();
*
* table.maxCellWidth = [ 10, 8 ];
*
* var widths = table.maxCellWidth;
* // returns [ 10, 8 ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'maxCellWidth', getMaxCellWidth, setMaxCellWidth );

/**
* Maximum table width in units of grapheme clusters (i.e., visual characters).
*
* @name maxWidth
* @memberof UnicodeTable.prototype
* @type {(NonNegativeInteger|null)}
* @throws {TypeError} must be a nonnegative integer or null
* @default +infinity
*
* @example
* var table = new UnicodeTable();
*
* table.maxWidth = 50;
*
* var width = table.maxWidth;
* // returns 50
*/
setReadWriteAccessor( UnicodeTable.prototype, 'maxWidth', getMaxWidth, setMaxWidth );

/**
* Cell left padding(s) in units of whitespace.
*
* @name paddingLeft
* @memberof UnicodeTable.prototype
* @type {(Collection<NonNegativeInteger>|NonNegativeInteger)}
* @throws {TypeError} must be a nonnegative integer or an array of nonnegative integers
* @default 1
*
* @example
* var table = new UnicodeTable();
*
* table.paddingLeft = 3;
*
* var padding = table.paddingLeft;
* // returns 3
*
* @example
* var table = new UnicodeTable();
*
* table.paddingLeft = [ 3, 2 ];
*
* var paddings = table.paddingLeft;
* // returns [ 3, 2 ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'paddingLeft', getPaddingLeft, setPaddingLeft );

/**
* Cell right padding(s) in units of whitespace.
*
* @name paddingRight
* @memberof UnicodeTable.prototype
* @type {(Collection<NonNegativeInteger>|NonNegativeInteger)}
* @throws {TypeError} must be a nonnegative integer or an array of nonnegative integers
* @default 1
*
* @example
* var table = new UnicodeTable();
*
* table.paddingRight = 3;
*
* var padding = table.paddingRight;
* // returns 3
*
* @example
* var table = new UnicodeTable();
*
* table.paddingRight = [ 3, 2 ];
*
* var paddings = table.paddingRight;
* // returns [ 3, 2 ]
*/
setReadWriteAccessor( UnicodeTable.prototype, 'paddingRight', getPaddingRight, setPaddingRight );

/**
* Row separator character(s).
*
* @name rowSeparator
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a string
* @default ''
*
* @example
* var table = new UnicodeTable();
*
* table.rowSeparator = '$=';
*
* var separator = table.rowSeparator;
* // returns '$='
*/
setReadWriteAccessor( UnicodeTable.prototype, 'rowSeparator', getRowSeparator, setRowSeparator );

/**
* Vertical line separator mode.
*
* @name verticalSeparatorMode
* @memberof UnicodeTable.prototype
* @type {string}
* @throws {TypeError} must be a supported line separator mode
* @default 'resume'
*
* @example
* var table = new UnicodeTable();
*
* table.verticalSeparatorMode = 'repeat';
*
* var mode = table.verticalSeparatorMode;
* // returns 'repeat'
*/
setReadWriteAccessor( UnicodeTable.prototype, 'verticalSeparatorMode', getVerticalSeparatorMode, setVerticalSeparatorMode );

/**
* Retrieves a single data element from a table.
*
* @name get
* @memberof UnicodeTable.prototype
* @type {Function}
* @param {NonNegativeInteger} i - index for the first dimension (i.e., zero-based row number)
* @param {NonNegativeInteger} j - index for the second dimension (i.e., zero-based column number)
* @throws {TypeError} first argument must be a nonnegative integer
* @throws {TypeError} second argument must be a nonnegative integer
* @throws {RangeError} index is out-of-bounds
* @returns {*} data element
*
* @example
* var table = new UnicodeTable( [ [ 1, 2 ], [ 3, 4 ] ], {
*     'headers': [ 'A', 'B' ]
* });
*
* var v = table.get( 0, 0 );
* // returns 1
*
* v = table.get( 1, 1 );
* // returns 4
*/
setReadOnly( UnicodeTable.prototype, 'get', getter );

/**
* Appends one or more rows to a table.
*
* @name push
* @memberof UnicodeTable.prototype
* @type {Function}
* @param {(Object|Collection|VectorLike|MatrixLike)} data - row(s) to add
* @throws {TypeError} must provide an object, an array-like object, or an ndarray
* @throws {TypeError} must provide data containing the correct number of columns
* @returns {UnicodeTable} table instance
*
* @example
* var ndarray2array = require( '@stdlib/ndarray/to-array' );
*
* var table = new UnicodeTable( [ [ 1, 2 ], [ 3, 4 ] ] );
* var data = ndarray2array( table.data );
* // returns [ [ 1, 2 ], [ 3, 4 ] ]
*
* table.push( [ 5, 6 ] );
* data = ndarray2array( table.data );
* // returns [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]
*/
setReadOnly( UnicodeTable.prototype, 'push', push );

/**
* Renders a table.
*
* @name render
* @memberof UnicodeTable.prototype
* @type {Function}
* @throws {Error} unable to accommodate all table columns within maximum table width
* @returns {string} rendered table
*
* @example
* var table = new UnicodeTable( [ [ 1, 2 ], [ 3, 4 ] ], {
*     'headers': [ 'A', 'B' ]
* });
*
* var str = table.render();
* // returns '...'
*/
setReadOnly( UnicodeTable.prototype, 'render', render );

/**
* Sets a single data element in a table to a specified value.
*
* @name set
* @memberof UnicodeTable.prototype
* @type {Function}
* @param {NonNegativeInteger} i - index for the first dimension (i.e., zero-based row number)
* @param {NonNegativeInteger} j - index for the second dimension (i.e., zero-based column number)
* @param {*} value - value to set
* @throws {TypeError} first argument must be a nonnegative integer
* @throws {TypeError} second argument must be a nonnegative integer
* @throws {RangeError} index is out-of-bounds
* @returns {UnicodeTable} table instance
*
* @example
* var table = new UnicodeTable( [ [ 1, 2 ], [ 3, 4 ] ], {
*     'headers': [ 'A', 'B' ]
* });
*
* var v = table.get( 1, 0 );
* // returns 3
*
* table.set( 1, 0, 5 );
*
* v = table.get( 1, 0 );
* // returns 5
*/
setReadOnly( UnicodeTable.prototype, 'set', setter );


// EXPORTS //

module.exports = UnicodeTable;
