/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-invalid-this */

'use strict';

// MODULES //

var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' ).isPrimitive;
var isInteger = require( '@stdlib/assert/is-integer' ).isPrimitive;
var isArray = require( '@stdlib/assert/is-array' );
var isCollection = require( '@stdlib/assert/is-collection' );
var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var setReadOnlyAccessor = require( '@stdlib/utils/define-nonenumerable-read-only-accessor' );
var setNonEnumerableProperty = require( '@stdlib/utils/define-nonenumerable-property' );
var min = require( '@stdlib/math/base/special/fast/min' );
var zeros = require( '@stdlib/array/base/zeros' );
var resolveGetter = require( '@stdlib/array/base/resolve-getter' );
var format = require( '@stdlib/string/format' );


// FUNCTIONS //

/**
* Returns a boolean indicating if a value is a FIFO array.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is a FIFO array
*/
function isFifoArray( value ) {
	return (
		value instanceof FifoArray ||
		(
			typeof value === 'object' &&
			value !== null &&
			value.constructor.name === 'FifoArray' &&
			typeof value._length === 'number' && // eslint-disable-line no-underscore-dangle
			typeof value._offset === 'number' && // eslint-disable-line no-underscore-dangle
			typeof value._buffer === 'object' // eslint-disable-line no-underscore-dangle
		)
	);
}

/**
* Resolves an index into the underlying buffer.
*
* @private
* @param {NonNegativeInteger} size - capacity
* @param {NonNegativeInteger} offset - index of the first indexed element
* @param {NonNegativeInteger} idx - view index
* @returns {NonNegativeInteger} buffer index
*/
function toIndex( size, offset, idx ) {
	return ( offset+idx ) % size;
}


// MAIN //

/**
* FIFO queue array constructor.
*
* @private
* @constructor
* @param {(NonNegativeInteger|Array)} [arg] - queue capacity or an array-like object containing initial values
* @throws {TypeError} invalid first argument
* @returns {FifoArray} FIFO array
*
* @example
* var arr = new FifoArray( 10 );
* // returns <FifoArray>
*/
function FifoArray() { // TODO: move to array/generic-fifo
	var nargs;
	var arg;
	var buf;
	var len;

	nargs = arguments.length;
	if ( !( this instanceof FifoArray ) ) {
		if ( nargs === 0 ) {
			return new FifoArray();
		}
		return new FifoArray( arguments[ 0 ] );
	}
	if ( nargs === 0 ) {
		buf = [];
		len = 0;
	} else {
		arg = arguments[ 0 ];
		if ( isNonNegativeInteger( arg ) ) {
			buf = zeros( arg );
			len = 0;
		} else if ( isArray( arg ) ) {
			buf = arg; // NOTE: not copying is intentional in order to allow creating a FIFO view; however, it does mean that an input argument will be mutated!
			len = arg.length;
		} else {
			throw new TypeError( format( 'invalid argument. Unsupported argument type. Value: `%s`.', arg ) );
		}
	}
	setReadOnly( this, '_buffer', buf );
	setNonEnumerableProperty( this, '_size', buf.length );
	setNonEnumerableProperty( this, '_length', len );
	setNonEnumerableProperty( this, '_offset', 0 );
	return this;
}

/**
* Constructor name.
*
* @name name
* @memberof FifoArray
* @readonly
* @type {string}
* @default 'FifoArray'
*
* @example
* var name = FifoArray.name;
* // returns 'FifoArray'
*/
setReadOnly( FifoArray, 'name', 'FifoArray' );

/**
* Converts a view index to an index into the underlying data buffer.
*
* @private
* @name _idx
* @memberof FifoArray.prototype
* @type {Function}
* @param {NonNegativeInteger} idx - view index
* @returns {NonNegativeInteger} buffer index
*/
setReadOnly( FifoArray.prototype, '_idx', function get( idx ) {
	return toIndex( this._size, this._offset, idx );
});

/**
* Increments the pointer to the first indexed element (i.e., the "oldest" element) in the underlying data buffer.
*
* @private
* @name _nextOffset
* @memberof FifoArray.prototype
* @type {Function}
* @returns {NonNegativeInteger} index offset
*/
setReadOnly( FifoArray.prototype, '_nextOffset', function nextOffset() {
	return ( this._offset+1 ) % this._size;
});

/**
* Decrements the pointer to the first indexed element (i.e., the "oldest" element) in the underlying data buffer.
*
* @private
* @name _prevOffset
* @memberof FifoArray.prototype
* @type {Function}
* @returns {NonNegativeInteger} index offset
*/
setReadOnly( FifoArray.prototype, '_prevOffset', function prevOffset() {
	var idx = this._offset - 1;
	if ( idx < 0 ) {
		idx = this._size - 1;
	}
	return idx;
});

/**
* Returns a queue element located at integer position (index) `i`, with support for both nonnegative and negative integer indices.
*
* @name at
* @memberof FifoArray.prototype
* @type {Function}
* @param {integer} idx - element index
* @throws {TypeError} `this` must be a FIFO array
* @throws {TypeError} must provide an integer
* @returns {(*|void)} queue element
*
* @example
* var arr = new FifoArray( [ 0, 0, 0 ] );
*
* arr.set( 1, 0 );
* arr.set( 2, 1 );
* arr.set( 3, 2 );
*
* var v = arr.at( 0 );
* // returns 1
*
* v = arr.at( -1 );
* // returns 3
*
* v = arr.at( 100 );
* // returns undefined
*/
setReadOnly( FifoArray.prototype, 'at', function at( idx ) {
	var buf;
	var len;

	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	if ( !isInteger( idx ) ) {
		throw new TypeError( format( 'invalid argument. Must provide an integer. Value: `%s`.', idx ) );
	}
	len = this._length;
	buf = this._buffer;
	if ( idx < 0 ) {
		idx += len;
	}
	if ( idx < 0 || idx >= len ) {
		return;
	}
	return buf[ this._idx( idx ) ];
});

/**
* Clears a queue.
*
* @name clear
* @memberof FifoArray.prototype
* @type {Function}
* @throws {TypeError} `this` must be a FIFO array
* @returns {FifoArray} Fifo array
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var len = arr.length;
* // returns 3
*
* arr.clear();
*
* len = arr.length;
* // returns 0
*/
setReadOnly( FifoArray.prototype, 'clear', function clear() {
	var i;
	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	// Reset buffer elements in order to free up references...
	for ( i = 0; i < this._length; i++ ) {
		this._buffer[ this._idx( i ) ] = 0;
	}
	// Reset the queue:
	this._length = 0;
	this._offset = 0;

	return this;
});

/**
* Returns an element from the queue.
*
* @name get
* @memberof FifoArray.prototype
* @type {Function}
* @param {NonNegativeInteger} idx - element index
* @throws {TypeError} `this` must be a FIFO array
* @throws {TypeError} must provide a nonnegative integer
* @returns {(*|void)} array element
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var v = arr.get( 0 );
* // returns 1
*
* arr.set( [ 5, 6 ], 0 );
*
* v = arr.get( 0 );
* // returns 5
*
* v = arr.get( 100 );
* // returns undefined
*/
setReadOnly( FifoArray.prototype, 'get', function get( idx ) {
	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	if ( !isNonNegativeInteger( idx ) ) {
		throw new TypeError( format( 'invalid argument. Must provide a nonnegative integer. Value: `%s`.', idx ) );
	}
	if ( idx >= this._length ) {
		return;
	}
	return this._buffer[ this._idx( idx ) ];
});

/**
* Number of queued elements.
*
* @name length
* @memberof FifoArray.prototype
* @readonly
* @type {NonNegativeInteger}
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var len = arr.length;
* // returns 3
*/
setReadOnlyAccessor( FifoArray.prototype, 'length', function get() {
	return this._length;
});

/**
* Removes the oldest element from the queue and returns that removed element.
*
* ## Notes
*
* -   If the queue is empty, the method returns `undefined`.
*
* @name pop
* @memberof FifoArray.prototype
* @type {Function}
* @throws {TypeError} `this` must be a FIFO array
* @returns {(*|void)} queue element
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var v = arr.get( 0 );
* // returns 1
*
* var len = arr.length;
* // returns 3
*
* v = arr.pop();
* // returns 1
*
* len = arr.length;
* // returns 2
*
* v = arr.get( 0 );
* // returns 2
*/
setReadOnly( FifoArray.prototype, 'pop', function pop() {
	var v;
	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	if ( this._length === 0 ) {
		return;
	}
	// Retrieve the oldest element:
	v = this._buffer[ this._offset ];

	// Reset the buffer element in order to free up references:
	this._buffer[ this._offset ] = 0;

	// Increment the pointer to the first indexed element to point to the next oldest element in the queue:
	this._offset = this._nextOffset();

	// Decrement the queue length:
	this._length -= 1;

	return v;
});

/**
* Adds one or more elements to the end of the queue and returns the number of queued elements.
*
* @name push
* @memberof FifoArray.prototype
* @type {Function}
* @param {...*} value - one or more values to queue
* @throws {TypeError} `this` must be a FIFO array
* @returns {NonNegativeInteger} number of queued elements
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var v = arr.get( 0 );
* // returns 1
*
* var len = arr.length;
* // returns 3
*
* // Push a single element to an already full queue:
* len = arr.push( 4 );
* // returns 3
*
* len = arr.length;
* // returns 3
*
* v = arr.get( 0 );
* // returns 2
*
* v = arr.get( arr.length-1 );
* // returns 4
*
* // Push multiple elements to an already full queue:
* len = arr.push( 5, 6 );
* // returns 3
*
* v = arr.get( 0 );
* // returns 4
*
* v = arr.get( arr.length-1 );
* // returns 6
*
* // Resize the queue to allow more queued elements:
* arr.resize( 10 );
*
* len = arr.length;
* // returns 3
*
* // Push multiple elements to a partially full queue:
* len = arr.push( 7, 8, 9 );
* // returns 6
*
* v = arr.get( 0 );
* // returns 4
*
* v = arr.get( arr.length-1 );
* // returns 9
*
* len = arr.length;
* // returns 6
*
* // Push multiple elements to fill the queue:
* len = arr.push( 10, 11, 12, 13, 14 );
* // returns 10
*
* v = arr.get( 0 );
* // returns 5
*
* v = arr.get( arr.length-1 );
* // returns 14
*
* // Shrink the queue:
* arr.resize( 3 );
*
* len = arr.length;
* // returns 3
*
* v = arr.get( 0 );
* // returns 12
*
* v = arr.get( arr.length-1 );
* // returns 14
*/
setReadOnly( FifoArray.prototype, 'push', function push() {
	var nargs;
	var len;
	var N;
	var M;
	var i;
	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	nargs = arguments.length;
	len = this._length;

	// Check for trivial cases in which there is nothing to queue...
	if ( this._size === 0 || nargs === 0 ) {
		return len;
	}
	// Check whether we have yet to fill the queue and don't need to worry about replacing previously queued elements...
	N = this._size - len;
	if ( N > 0 ) {
		M = min( nargs, N );
		for ( i = 0; i < M; i++ ) {
			this._buffer[ this._idx( len+i ) ] = arguments[ i ];
		}
	} else {
		M = 0;
	}
	// If the queue is full, we need to replace previously queued elements...
	for ( i = M; i < nargs; i++ ) {
		this._buffer[ this._offset ] = arguments[ i ];
		this._offset = this._nextOffset();
	}
	this._length += M;
	return this._length;
});

/**
* Resizes the queue capacity.
*
* @name resize
* @memberof FifoArray.prototype
* @type {Function}
* @param {NonNegativeInteger} size - queue capacity
* @throws {TypeError} `this` must be a FIFO array
* @throws {TypeError} must provide a nonnegative integer
* @returns {FifoArray} Fifo array
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var size = arr.size;
* // returns 3
*
* arr.resize( 10 );
*
* size = arr.size;
* // returns 10
*
* arr.resize( 2 );
*
* size = arr.size;
* // returns 2
*
* var v = arr.get( 0 );
* // returns 2
*/
setReadOnly( FifoArray.prototype, 'resize', function resize( size ) {
	var buf;
	var tmp;
	var S;
	var N;
	var M;
	var i;
	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	if ( !isNonNegativeInteger( size ) ) {
		throw new TypeError( format( 'invalid argument. Must provide a nonnegative integer. Value: `%s`.', size ) );
	}
	buf = this._buffer;
	S = this._size;
	N = this._length;

	// Case: no resizing necessary
	if ( size === S ) {
		return this;
	}
	// Case: queue has not reached capacity, so queue should be contiguous, and we are asked to simply increase the queue capacity
	if ( this._offset+N <= S && size > S ) {
		// We can just extend the underlying buffer...
		for ( i = 0; i < size-S; i++ ) {
			buf.push( 0 );
		}
		this._size = size;
		return this;
	}
	// Case: queue has either reached capacity, in which case the queue is no longer guaranteed to be contiguous, or we need to shrink the queue capacity; in either case, copy to a temporary copy in order to allow for shrinking/growing the buffer without losing references to buffer data
	tmp = [];
	for ( i = 0; i < N; i++ ) {
		tmp.push( buf[ this._idx( i ) ] );
	}
	// Case: grow the queue
	if ( size > S ) {
		for ( i = 0; i < size-S; i++ ) {
			buf.push( 0 );
		}
		// Copy over all previously queued elements...
		for ( i = 0; i < N; i++ ) {
			buf[ i ] = tmp[ i ];
		}
		// Reset the offset given that we just copied:
		this._offset = 0;

		// Update the queue size:
		this._size = size;

		return this;
	}
	// Case: shrink the queue
	this._size = size;
	buf.length = size;
	S = size;

	// Determine the number of queued elements to keep...
	if ( S >= N ) {
		M = N;
	} else {
		M = S;
	}
	// Copy over only the most recently queued elements...
	for ( i = 0; i < M; i++ ) {
		buf[ i ] = tmp[ N-M+i ];
	}
	// Reset the offset given that we just copied:
	this._offset = 0;

	// Update the queue size:
	this._size = size;

	// Update the number of queued elements:
	this._length = M;

	return this;
});

/**
* Sets a queue element.
*
* ## Notes
*
* -   When provided an array, we must check whether the source array shares the same buffer as the target array and whether the underlying memory overlaps. In particular, we are concerned with the following scenario:
*
*     ```text
*     buf:                ---------------------
*     src: ---------------------
*     ```
*
*     In the above, as we copy values from `src`, we will overwrite values in the `src` view, resulting in duplicated values copied into the end of `buf`, which is not intended. Hence, to avoid overwriting source values, we must **copy** source values to a temporary array.
*
*     In the other overlapping scenario,
*
*     ```text
*     buf: ---------------------
*     src:                ---------------------
*     ```
*
*     by the time we begin copying into the overlapping region, we are copying from the end of `src`, a non-overlapping region, which means we don't run the risk of copying copied values, rather than the original `src` values, as intended.
*
* @name set
* @memberof FifoArray.prototype
* @type {Function}
* @param {(Collection|FifoArray|*)} value - value(s)
* @param {NonNegativeInteger} [i=0] - element index at which to start writing values
* @throws {TypeError} `this` must be a FIFO array
* @throws {TypeError} index argument must be a nonnegative integer
* @throws {RangeError} index argument is out-of-bounds
* @throws {RangeError} target array lacks sufficient storage to accommodate source values
* @returns {void}
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var v = arr.get( 0 );
* // returns 1
*
* arr.set( [ 5, 6 ], 0 );
*
* v = arr.get( 0 );
* // returns 5
*/
setReadOnly( FifoArray.prototype, 'set', function set( value ) {
	var sbuf;
	var idx;
	var buf;
	var tmp;
	var get;
	var N;
	var i;

	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	if ( arguments.length > 1 ) {
		idx = arguments[ 1 ];
		if ( !isNonNegativeInteger( idx ) ) {
			throw new TypeError( format( 'invalid argument. Index argument must be a nonnegative integer. Value: `%s`.', idx ) );
		}
	} else {
		idx = 0;
	}
	buf = this._buffer;
	if ( isCollection( value ) ) {
		N = value.length;
		if ( idx+N > this._length ) {
			throw new RangeError( 'invalid arguments. Target array lacks sufficient storage to accommodate source values.' );
		}
		if ( isFifoArray( value ) ) {
			sbuf = value._buffer; // eslint-disable-line no-underscore-dangle
		} else {
			sbuf = value;
		}
		// Check for potentially overlapping memory...
		if ( sbuf === buf ) {
			// We need to copy source values... (note: we are being conservative here given that FIFO arrays have additional indexing misdirection complexity and figuring out whether there is actual overlap is likely more trouble than it is worth)
			get = resolveGetter( sbuf );
			tmp = [];
			for ( i = 0; i < sbuf.length; i++ ) {
				tmp.push( get( sbuf, i ) );
			}
			sbuf = tmp;
		}
		get = resolveGetter( sbuf );
		for ( i = 0; i < N; idx++, i++ ) {
			buf[ this._idx( idx ) ] = get( sbuf, i );
		}
		return;
	}
	if ( idx >= this._length ) {
		throw new RangeError( format( 'invalid argument. Index argument is out-of-bounds. Value: `%u`.', idx ) );
	}
	buf[ this._idx( idx ) ] = value;
});

/**
* Queue capacity.
*
* @name size
* @memberof FifoArray.prototype
* @readonly
* @type {NonNegativeInteger}
*
* @example
* var arr = new FifoArray( 10 );
*
* var len = arr.length;
* // returns 0
*
* var size = arr.size;
* // returns 10
*/
setReadOnlyAccessor( FifoArray.prototype, 'size', function get() {
	return this._size;
});

/**
* Removes the newest element from the queue and returns that removed element.
*
* ## Notes
*
* -   If the queue is empty, the method returns `undefined`.
*
* @name shift
* @memberof FifoArray.prototype
* @type {Function}
* @throws {TypeError} `this` must be a FIFO array
* @returns {(*|void)} queue element
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var len = arr.length;
* // returns 3
*
* var v = arr.shift();
* // returns 3
*
* len = arr.length;
* // returns 2
*/
setReadOnly( FifoArray.prototype, 'shift', function shift() {
	var v;
	var i;
	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	if ( this._length === 0 ) {
		return;
	}
	// Resolve the buffer index of the newest element:
	i = this._idx( this._length-1 );

	// Retrieve the newest element:
	v = this._buffer[ i ];

	// Reset the buffer element in order to free up references:
	this._buffer[ i ] = 0;

	// Decrement the queue length:
	this._length -= 1;

	return v;
});

/**
* Adds one or more elements to the beginning of the queue and returns the number of queued elements.
*
* ## Notes
*
* -   If provided multiple elements, the method queues those elements in the reverse order as they are provided, such that the first element is considered the "oldest" element and each subsequent element is considered "newer". The ensures that the first indexed element is the "oldest" queued element and matches `Array.prototype.unshift` behavior in which multiple provided elements are inserted as a chunk at the beginning of an array, in the exact same order in which the elements were passed in.
* -   Calling this method `n` times with a single argument does **not** yield the same results as calling this method one time with `n` arguments.
*
* @name unshift
* @memberof FifoArray.prototype
* @type {Function}
* @param {...*} value - one or more values to queue
* @throws {TypeError} `this` must be a FIFO array
* @returns {NonNegativeInteger} number of queued elements
*
* @example
* var arr = new FifoArray( [ 1, 2, 3 ] );
*
* var v = arr.get( 0 );
* // returns 1
*
* var len = arr.length;
* // returns 3
*
* // Add a single element to an already full queue:
* len = arr.unshift( 4 );
* // returns 3
*
* len = arr.length;
* // returns 3
*
* v = arr.get( 0 );
* // returns 4
*
* v = arr.get( arr.length-1 );
* // returns 2
*
* // Add multiple elements to an already full queue:
* len = arr.unshift( 5, 6 );
* // returns 3
*
* v = arr.get( 0 );
* // returns 5
*
* v = arr.get( arr.length-1 );
* // returns 4
*
* // Resize the queue to allow more queued elements:
* arr.resize( 10 );
*
* len = arr.length;
* // returns 3
*
* // Add multiple elements to a partially full queue:
* len = arr.unshift( 7, 8, 9 );
* // returns 6
*
* v = arr.get( 0 );
* // returns 7
*
* v = arr.get( arr.length-1 );
* // returns 4
*
* len = arr.length;
* // returns 6
*
* // Add multiple elements to fill the queue:
* len = arr.unshift( 10, 11, 12, 13, 14 );
* // returns 10
*
* v = arr.get( 0 );
* // returns 10
*
* v = arr.get( arr.length-1 );
* // returns 6
*
* // Shrink the queue:
* arr.resize( 3 );
*
* len = arr.length;
* // returns 3
*
* v = arr.get( 0 );
* // returns 9
*
* v = arr.get( arr.length-1 );
* // returns 6
*/
setReadOnly( FifoArray.prototype, 'unshift', function unshift() {
	var nargs;
	var len;
	var N;
	var M;
	var i;
	if ( !isFifoArray( this ) ) {
		throw new TypeError( 'invalid invocation. `this` is not a FIFO array.' );
	}
	nargs = arguments.length;
	len = this._length;

	// Check for trivial cases in which there is nothing to queue...
	if ( this._size === 0 || nargs === 0 ) {
		return len;
	}
	// Compute the queue length adjustment...
	N = this._size - len;
	if ( N > 0 ) {
		M = min( nargs, N );
	} else {
		M = 0;
	}
	// Insert elements in the queue in reverse order to match `Array.prototype.unshift` behavior...
	for ( i = 0; i < nargs; i++ ) {
		this._offset = this._prevOffset();
		this._buffer[ this._offset ] = arguments[ nargs-1-i ];
	}
	this._length += M;
	return this._length;
});


// EXPORTS //

module.exports = FifoArray;
