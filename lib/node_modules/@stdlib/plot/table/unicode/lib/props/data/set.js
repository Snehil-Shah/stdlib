/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-invalid-this */

'use strict';

// MODULES //

var isMatrixLike = require( '@stdlib/assert/is-matrix-like' );
var isCollection = require( '@stdlib/assert/is-collection' );
var assign = require( '@stdlib/ndarray/base/assign' );
var ndarray = require( '@stdlib/ndarray/base/ctor' );
var getShape = require( '@stdlib/ndarray/shape' );
var getBaseShape = require( '@stdlib/ndarray/base/shape' );
var getData = require( '@stdlib/ndarray/base/data-buffer' );
var shape2strides = require( '@stdlib/ndarray/base/shape2strides' );
var zeros = require( '@stdlib/array/base/zeros' );
var format = require( '@stdlib/string/format' );
var normalizeData = require( './../../normalize.js' );
var convertDictionary = require( './../../convert_dictionary.js' );
var convertCollection = require( './../../convert_collection.js' );
var FifoArray = require( './../../fifo.js' );


// VARIABLES //

var DTYPE = 'generic';
var ORDER = 'row-major';


// MAIN //

/**
* Sets the table data.
*
* @private
* @param {(Object|Collection<Object>|Collection<Collection>|MatrixLike)} data - table data
* @throws {TypeError} must be an object, an array of objects, an array of arrays, or a two-dimensional ndarray
* @throws {RangeError} must provide the correct number of columns
* @throws {RangeError} number of rows must not exceed the maximum data buffer size
*/
function set( data ) {
	var headers;
	var out;
	var tmp;
	var sh;

	// If provided an ndarray, explicitly copy ndarray data to a new contiguous ndarray in order to allow mutation of the underlying buffer and for the purposes of maintaining an internal FIFO queue...
	if ( isMatrixLike( data ) ) {
		sh = getShape( data );
		out = new FifoArray( zeros( sh[0]*sh[1] ) );
		out = new ndarray( DTYPE, out, sh, shape2strides( sh, ORDER ), 0, ORDER );
		assign( [ data, out ] );
	}
	// If provided a collection, convert to an ndarray...
	else if ( isCollection( data ) ) {
		out = convertCollection( data, this.headers ); // NOTE: the use of `this.headers`, rather than `this._headers`, is intentional, as we only want the list of header values (if they exist)
		if ( out.code ) { // out.code === 'ERR_MISSING_COLUMNS'
			throw new TypeError( format( 'invalid assignment. `%s` must be either an object, an array of objects, an array of arrays, or a two-dimensional ndarray. One or more of the provided data elements is missing expected column data. Expected columns: ["%s"]. Value: `%s`.', 'data', out.headers.join( '", "' ), JSON.stringify( data ) ) );
		}
		if ( out.headers ) {
			headers = out.headers;
		}
		out = out.data; // ndarray
	}
	// If provided anything else, process as a dictionary of columns...
	else {
		out = convertDictionary( data, this.headers ); // NOTE: the use of `this.headers`, rather than `this._headers`, is intentional, as we only want the list of header values (if they exist)
		if ( out.code ) {
			if ( out.code === 'ERR_EMPTY_OBJECT' ) {
				throw new TypeError( format( 'invalid assignment. `%s` must be either an object containing columns of data, an array of objects, an array of arrays, or a two-dimensional ndarray. Value: `%s`.', 'data', JSON.stringify( data ) ) );
			}
			if ( out.code === 'ERR_INVALID_OBJECT' ) {
				throw new TypeError( format( 'invalid assignment. `%s` must be either an object containing columns of data, an array of objects, an array of arrays, or a two-dimensional ndarray. Value: `%s`.', 'data', JSON.stringify( data ) ) );
			}
			// out.code === 'ERR_UNEQUAL_COLUMN_LENGTHS'
			throw new TypeError( format( 'invalid assignment. `%s` must be either an object containing columns of data, an array of objects, an array of arrays, or a two-dimensional ndarray. Each provided data column must have the same number of rows. Value: `%s`.', 'data', JSON.stringify( data ) ) );
		}
		if ( out.headers ) {
			headers = out.headers;
		}
		out = out.data; // ndarray
	}
	// Ensure that the provided data does not have too many rows...
	sh = getBaseShape( out, false );
	if ( sh[ 0 ] > this._bufferSize ) {
		throw new RangeError( format( 'invalid assignment. `%s` exceeds maximum data buffer size. Either increase the table buffer size or provide fewer rows of data. Buffer size: %u. Number of rows: %u.', 'data', this._bufferSize, sh[ 0 ] ) );
	}
	// Ensure that the provided data has the expected number of columns...
	if ( this._numColumns ) {
		if ( sh[ 1 ] !== this._numColumns ) {
			throw new RangeError( format( 'invalid assignment. `%s` must have %d columns in order to match the number of table columns. Number of columns: %u.', 'data', this._numColumns, sh[ 1 ] ) );
		}
	} else {
		this._numColumns = sh[ 1 ];
	}
	// Normalize the underlying table data buffer:
	normalizeData( getData( out ), sh, this._format );

	// Anytime a user sets table data, assume that the data has changed (note: performing a deep equality check is likely too expensive and not worth the effort) and thus, if not in "quiet" mode, always emit a 'change' event...
	this._data = out;
	if ( headers !== void 0 ) {
		tmp = this._quiet;
		this._quiet = true; // avoid triggering a 'change' event
		this.headers = headers; // NOTE: assigning to `this.headers` is intentional in order to ensure proper processing of headers
		this._quiet = tmp;
	}
	if ( !this._quiet ) {
		this.emit( 'change' );
	}
}


// EXPORTS //

module.exports = set;
