/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-invalid-this */

'use strict';

// MODULES //

var isMatrixLike = require( '@stdlib/assert/is-matrix-like' );
var isCollection = require( '@stdlib/assert/is-collection' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var numelDimension = require( '@stdlib/ndarray/base/numel-dimension' );
var shape2strides = require( '@stdlib/ndarray/base/shape2strides' );
var assign = require( '@stdlib/ndarray/base/assign' );
var ndarray = require( '@stdlib/ndarray/ctor' );
var emptyLike = require( '@stdlib/ndarray/empty-like' );
var flatten2d = require( '@stdlib/array/base/flatten2d' );
var shape = require( '@stdlib/array/shape' );
var objectKeys = require( '@stdlib/utils/keys' );
var splitGraphemeClusters = require( '@stdlib/string/split-grapheme-clusters' );
var format = require( '@stdlib/string/format' );


// VARIABLES //

var DTYPE = 'generic';
var ORDER = 'row-major';


// FUNCTIONS //

/**
* Creates a two-dimensional ndarray having a specified data buffer and shape.
*
* @private
* @param {Array} buffer - data buffer
* @param {NonNegativeIntegerArray} shape - shape
* @returns {ndarray} two-dimensional ndarray
*/
function matrix( buffer, shape ) {
	return new ndarray( DTYPE, buffer, shape, shape2strides( shape, ORDER ), 0, ORDER ); // eslint-disable-line max-len
}

/**
* Converts table data provided as an array-like object.
*
* @private
* @param {Collection} data - input data
* @param {(ObjectArray|null)} headers - table headers
* @throws {TypeError} invalid input data
* @returns {(Object|Error)} table data
*/
function convertCollection( data, headers ) {
	var keys;
	var out;
	var flg;
	var sh;
	var d;
	var i;
	var j;
	var k;

	sh = shape( data );

	// If we were provided a nested array, flatten in row-major order...
	if ( sh.length >= 2 ) {
		sh = [ sh[ 0 ], sh[ 1 ] ]; // only concern ourselves with the first two dimensions
		return {
			'data': matrix( flatten2d( data, sh, false ), sh ),
			'headers': null
		};
	}
	// If we were provided a one-dimensional array, assume that we were provided a list of objects...

	// If we don't already have headers, infer the headers from the first array element...
	if ( headers === null ) {
		keys = objectKeys( data[ 0 ] );
		flg = true;
	} else {
		keys = headers;
	}
	out = [];
	for ( i = 0; i < sh[ 0 ]; i++ ) {
		d = data[ i ];
		for ( j = 0; j < keys.length; j++ ) {
			k = keys[ j ];
			if ( hasOwnProp( d, k ) ) {
				out.push( d[ k ] );
			} else {
				return new Error( format( 'invalid assignment. `%s` must be either an object, an array of objects, an array of arrays, or a two-dimensional ndarray. One or more of the provided data elements is missing expected column data. Expected columns: ["%s"]. Value: `%s`.', 'data', keys.join( '", "' ), JSON.stringify( data ) ) );
			}
		}
	}
	return {
		'data': matrix( out, [ sh[ 0 ], keys.length ] ),
		'headers': ( flg ) ? keys : null
	};
}

/**
* Converts table data provided as an object.
*
* @private
* @param {*} data - input data
* @param {(ObjectArray|null)} headers - table headers
* @throws {TypeError} invalid input data
* @returns {(Object|Error)} table data
*/
function convertOther( data, headers ) {
	var keys;
	var out;
	var flg;
	var M;
	var N;
	var i;
	var j;
	var k;

	// If we don't already have headers, infer the headers from the provided object...
	if ( headers === null ) {
		keys = objectKeys( data );
		flg = true;
	} else {
		keys = headers;
	}
	// If provided an empty object (or an object without enumerable properties), likely a user error...
	if ( keys.length === 0 ) {
		return new Error( format( 'invalid assignment. `%s` must be either an object, an array of objects, an array of arrays, or a two-dimensional ndarray. Value: `%s`.', 'data', JSON.stringify( data ) ) );
	}
	// Validate that each column of data is the same length...
	M = data[ keys[0] ].length;
	N = keys.length;
	for ( i = 1; i < N; i++ ) {
		if ( data[ keys[i] ].length !== M ) {
			return new Error( format( 'invalid assignment. `%s` must be either an object, an array of objects, an array of arrays, or a two-dimensional ndarray. Each provided data column must have the same number of rows. Value: `%s`.', 'data', JSON.stringify( data ) ) );
		}
	}
	// Flatten the dictionary of columns into a row-major linear buffer...
	out = [];
	for ( i = 0; i < M; i++ ) {
		for ( j = 0; j < N; j++ ) {
			k = keys[ j ];
			out.push( data[ k ][ i ] );
		}
	}
	return {
		'data': matrix( out, [ M, N ] ),
		'headers': ( flg ) ? keys : null
	};
}

/**
* Normalizes table data.
*
* @private
* @param {Array} buffer - data buffer
* @returns {Array} modified data buffer
*/
function normalizeData( buffer ) {
	var ch;
	var v;
	var i;
	for ( i = 0; i < buffer.length; i++ ) {
		v = String( buffer[ i ] );
		ch = splitGraphemeClusters( v );
		buffer[ i ] = {
			'raw': buffer[ i ],
			'value': v,
			'graphemes': ch,
			'length': ch.length
		};
	}
	return buffer;
}


// MAIN //

/**
* Sets the table data.
*
* @private
* @param {(Object|Collection<Object>|Collection<Collection>|MatrixLike)} data - table data
* @throws {TypeError} must be an object, an array of objects, an array of arrays, or a two-dimensional ndarray
* @throws {RangeError} must provide the correct number of columns
* @throws {RangeError} number of rows must not exceed the maximum data buffer size
*/
function set( data ) {
	var headers;
	var out;
	var tmp;

	// If provided an ndarray, explicitly copy ndarray data to a new contiguous ndarray in order to allow mutation of the underlying "generic" buffer and for the purposes of maintaining an internal FIFO queue...
	if ( isMatrixLike( data ) ) {
		out = emptyLike( data, {
			'dtype': DTYPE
		});
		assign( [ data, out ] );
	}
	// If provided a collection, convert to an ndarray...
	else if ( isCollection( data ) ) {
		out = convertCollection( data, this.headers ); // NOTE: the use of `this.headers`, rather than `this._headers` is intentional, as we only want the list of header values (if they exist)
		if ( out instanceof Error ) {
			throw out;
		}
		if ( out.headers ) {
			headers = out.headers;
		}
		out = out.data; // ndarray
	}
	// If provided anything else, process as a dictionary of columns...
	else {
		out = convertOther( data, this.headers ); // NOTE: the use of `this.headers`, rather than `this._headers` is intentional, as we only want the list of header values (if they exist)
		if ( out instanceof Error ) {
			throw out;
		}
		if ( out.headers ) {
			headers = out.headers;
		}
		out = out.data; // ndarray
	}
	// Ensure that the provided data does not have too many rows...
	if ( numelDimension( out, 0 ) > this._bufferSize ) {
		throw new RangeError( format( 'invalid assignment. `%s` exceeds maximum data buffer size. Buffer size: %u. Number of rows: `%u`.', 'data', this._bufferSize, numelDimension( out, 0 ) ) );
	}
	// Ensure that the provided data has the expected number of columns...
	if ( this._numColumns ) {
		if ( numelDimension( out, 1 ) !== this._numColumns ) {
			throw new RangeError( format( 'invalid assignment. `%s` must have %d columns in order to match the number of table columns. Number of columns: `%u`.', 'data', this._numColumns, numelDimension( out, 1 ) ) );
		}
	} else {
		this._numColumns = numelDimension( out, 1 );
	}
	// Normalize the underlying table data buffer:
	normalizeData( out.data );

	// Anytime a user sets table data, assume that the data has changed (note: performing a deep equality check is likely too expensive and not worth the effort) and thus, if not in "quiet" mode, always emit a 'change' event...
	this._data = out;
	if ( headers !== void 0 ) {
		tmp = this._quiet;
		this._quiet = true; // avoid triggering a 'change' event
		this.headers = headers; // NOTE: assigning to `this.headers` is intentional in order to ensure proper processing of headers
		this._quiet = tmp;
	}
	if ( !this._quiet ) {
		this.emit( 'change' );
	}
}


// EXPORTS //

module.exports = set;
